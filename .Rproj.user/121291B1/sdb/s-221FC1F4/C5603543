{
    "contents" : "list.of.packages <- c(\"scatterplot3d\", \"parallel\")\nnew.packages <- setdiff(list.of.packages, installed.packages()[,\"Package\"])\nif(length(new.packages)) install.packages(new.packages, repos='http://cran.us.r-project.org')\n\n#Don’t use library() or require(). These modify the search path, affecting what functions are available from the global environment. \n#It’s better to use the DESCRIPTION to specify your package’s requirements\n#library(scatterplot3d)\n## EM algorithm\n\n\n## prepare data\n\n\n## clusterize observed MLE parameters\n## construct rk vectors (1/0) for EM (based on cluster membership)\n## find initial a (and b) parameters for EM (maximisation)\n## compute initial weights based on (1/0) rk vectors (expectation)\n## returns list with two values: vector of weights and matrix of parameters\n\n\n\ninitialize_by_clustering <- function (data, params, mutation_position = \"middle\", cluster.number = 4, model = NULL){\n  if (model == \"weibull\"){\n    parclust <-params[,c(\"lambda_weib_root\", \"p_root\")]\n    scaling <-max(parclust[,2])/max(parclust[,1])\n    parclust_scaled <- data.frame(lambda_weib_root = scaling*parclust[,1], p_root = parclust[,2])\n  }\n  else {\n    parclust_scaled <- data.frame(lambda_exp_root = params[,c(\"lambda_exp_root\")])\n  }\n  \n  clusters <-kmeans(parclust_scaled, cluster.number)\n  categories <- seq(from = 1, to = cluster.number, by = 1)\n  rkvectors <- sapply(categories, function(k){\n    rk <-sapply(clusters$cluster, function(category){\n      if (category == k){1} \n      else {0}\n    })\n  })\n  rownames(rkvectors) <- params$node\n  \n  init_params <-compute_params(data = data, rkvectors = rkvectors, model = model, mutation_position = mutation_position)\n  \n  init_weights <- compute_weights(rkvectors)\n  \n  list(iparameters = init_params, iweights = init_weights)\n}\n\n\n## alternative: choose random a (and b) \n## set equal weights for all categories\n## returns list with two values: vector of weights and matrix of parameters\n\ninitialize_random <- function (params, cluster.number = 4, model = NULL){\n  if (model == \"weibull\"){\n    init_params <-matrix(ncol =2, nrow = cluster.number, byrow = TRUE)\n    colnames(init_params) = c(\"lambda\", \"p\")\n    p_roots <- params[, \"p_root\"]\n    prand <- exp(runif(cluster.number, min=min(log (p_roots)),max=max(log (p_roots))))\n    init_params[, \"p\"] <-prand\n    lambda_roots <- params[, \"lambda_weib_root\"]\n    lambdarand <- exp(runif(cluster.number, min=min(log (lambda_roots)),max=max(log (lambda_roots))))\n    init_params[, \"lambda\"] <-lambdarand\n  }\n  else if (model == \"exponential\"){\n    init_params <-matrix( ncol =1, nrow = cluster.number, byrow = TRUE)\n    colnames(init_params) = c(\"lambda\")\n    lambda_roots <- params[, \"lambda_exp_root\"]\n    lambdarand <- exp(runif(cluster.number, min=min(log (lambda_roots)),max=max(log (lambda_roots))))\n    init_params[, \"lambda\"] <-lambdarand\n  }\n  \n  init_weights = rep(1/cluster.number, cluster.number)\n  list(iparameters = init_params, iweights = init_weights)\n}\n\ninitialize_by <- function (init_params, init_weights, model = NULL, cluster.number = 4){\n  if (class(init_params) != \"numeric\") {\n    stop (\"Invalid argument params: expected vector of length 2*cluster.number\")\n  }\n  if (model == \"weibull\"){\n    if (length(init_params) != 2*cluster.number) {\n      stop (\"Invalid params length: expected vector of length 2*cluster.number\")\n    }\n  }\n  else if (model == \"exponential\"){\n    if (length(init_params) != cluster.number) {\n      stop (\"Invalid params length: expected vector of length cluster.number\")\n    }\n  }\n  else {\n    stop (paste (c(\"Invalid model name: expected 'weibull' or 'exponential', recieved \", model), collpase = \"\"))\n  }\n  if (length(init_weights) != cluster.number) {\n    stop (\"Invalid weights length: expected vector of length cluster.number\")\n  }\n  if (sum(init_weights) != 1){\n    stop (\"Invalid weights value: sum of weights must be equal to 1\")\n  }\n  \n  categories <- seq(from = 1, to = cluster.number, by = 1)\n  if (model == \"weibull\"){\n    init_params <-matrix(init_params, ncol =2, nrow = cluster.number, byrow = TRUE)\n    colnames(init_params) = c(\"lambda\", \"p\")\n  }\n  else if (model == \"exponential\"){\n    init_params <-matrix(init_params, ncol =1, nrow = cluster.number, byrow = TRUE)\n    colnames(init_params) = c(\"lambda\")\n  }\n  \n  list(iparameters = init_params, iweights = init_weights)\n}\n\nfilter_unsolved <-function(data, params){\n  fparams <-params[!is.na(params$p_precision) ,]\n  fparams <-fparams[fparams$p_precision< 1e-5  ,]\n  fdata <- data[fparams$node]\n  list(fdata = fdata, fparams = fparams)\n}\n\nfilter_unsolved_and_single <-function(data, params){\n  fparams <-params[!is.na(params$p_precision),]\n  fparams <-fparams[fparams$p_precision< 1e-5,]\n  fparams <-fparams[fparams$events > 1,]\n  fdata <- data[fparams$node]\n  list(fdata = fdata, fparams = fparams)\n}\n\n\nem_procedure <-function(data, params, model = NULL, iter = 100, cluster.number= 4, init_method = c(\"cluster\", \"random\", \"by\"), init_params = NULL, init_weights = NULL, mutation_position = \"middle\",  filtering = c(\"single\", \"unsolved\"), trace = TRUE, trackfile = NULL, trackcount = 10){\n  if (filtering == \"single\"){\n    fi <- filter_unsolved_and_single(data=data, params=params)\n    fdata <- fi$fdata\n    fparams <- fi$fparams\n  }\n  else if (filtering == \"unsolved\"){\n    fi <- filter_unsolved(data=data, params=params)\n    fdata <- fi$fdata\n    fparams <- fi$fparams\n  }\n  else {\n    stop(\"Invalid argument filtering: must be either single or unsolved\")\n  }\n  \n  if (init_method == \"cluster\") {\n    init <- initialize_by_clustering(data=fdata, params=fparams, model = model, mutation_position = mutation_position, cluster.number = cluster.number)\n    iparameters <- init$iparameters\n    iweights <- init$iweights \n  }\n  else if (init_method == \"random\"){\n    init <- initialize_random(params=fparams, model = model, cluster.number = cluster.number)\n    iparameters <- init$iparameters\n    iweights <- init$iweights \n  }\n  else if (init_method == \"by\"){\n    if (is.null(init_params) || is.null(init_weights)){\n      stop (\"Chosen inititalization method requires init_params and init_weights arguments\")\n    }\n    init <- initialize_by(init_params, init_weights, model = model, cluster.number = cluster.number)\n    iparameters <- init$iparameters\n    iweights <- init$iweights \n  }\n  else {\n    stop (paste (\"Invalid initialization method \", method ))\n  }\n  \n  print (\"Initial parameters:\")\n  print (iparameters)\n  print (iweights)\n  \n  em_results <- em(data = fdata, parameters = iparameters, model = model, weights = iweights, iter= iter, mutation_position = mutation_position, cluster.number = cluster.number, trace = trace, trackfile = trackfile, trackcount = trackcount)\n\n}\n\n\nem <- function(data, model = NULL, parameters, weights, iter = 100, cluster.number= 4, mutation_position = \"middle\", trace = TRUE, trackfile = NULL, trackcount = 10){\n  if (trace){\n    myplot <- tracer(parameters, weights, cluster.number, init = TRUE)\n  }\n  old_lnL <- NULL\n  for (i in seq(1,iter,1)){\n    print (paste(c(\"------------Step \", i), collapse=\"\"))\n    rkvectors <- compute_rkvectors(data=data, parameters=parameters, model = model, weights=weights)\n    parameters <- compute_params(data=data, rkvectors=rkvectors, model = model, mutation_position = mutation_position)\n    weights <- compute_weights(rkvectors)\n    print(rkvectors)\n    print(weights)\n    if (trace){\n      myplot <- tracer(parameters, weights, cluster.number, myplot = myplot, init = FALSE)\n    }  \n    model_lnL <- compute_model_lnL(data=data, model = model,parameters=parameters, weights=weights)\n    print (\"model lnL\")\n    print(model_lnL)\n    if (!is.null(trackfile) && round(i/trackcount) == i/trackcount){\n      sink(paste(c(trackfile, \"_\", i), collapse=\"\"))\n      print(model_lnL)\n      sink()\n    }\n    if (!is.null(old_lnL) && model_lnL - old_lnL < 0.0001){\n      break\n    }\n    else {old_lnL <- model_lnL}\n  }\n  \n  model_bic <- bic(lnL = model_lnL, model = model, cluster.number = cluster.number, n = length(data))\n  print (\"data length\")\n  print (length(data))\n  print (\"model bic\")\n  print(model_bic)\n  list(parameters=parameters, rkvectors=rkvectors, weights=weights, lnL = model_lnL, bic = model_bic)\n}\n\ntracer <- function (parameters, weights, cluster.number, myplot,  init = FALSE){\n  colors <- c(\"red\", \"blue\", \"green\", \"black\", \"orange\", \"gray\", \"violet\")\n  if (ncol(parameters) == 2){ #weibull model\n    if (init){\n      myplot <- scatterplot3d(parameters[1,\"lambda\"], parameters[1,\"p\"], weights[1], color= colors[1], type=\"h\", xlim = c(0, 0.1), ylim = c(0,10), zlim = c(0,1), pch=19)\n      if (cluster.number > 1){\n        for (i in seq(2,cluster.number,1)){\n          myplot$points3d(parameters[i,\"lambda\"], parameters[i,\"p\"], weights[i], col= colors[i], pch=19, type=\"h\")\n        }\n      }\n    }\n    else {\n      for (i in seq(1,cluster.number,1)){\n        print (\"weights\")\n        print(weights)\n        myplot <- myplot\n        myplot$points3d(parameters[i,\"lambda\"], parameters[i,\"p\"], weights[i], col= colors[i], type=\"h\")\n      }\n    }\n  }\n  \n  else if (ncol(parameters) == 1){ #exponential model\n    if (init){\n      myplot <- plot(parameters[1,\"lambda\"], weights[1], col= colors[1],  xlim = c(0, 0.1), ylim = c(0,1), xlab = \"lambda\", ylab = \"weight\", pch=19)\n      if (cluster.number > 1){\n        for (i in seq(2,cluster.number,1)){\n          points(parameters[i,\"lambda\"], weights[i], col= colors[i], pch=19)\n        }\n      }\n    }\n    else {\n      for (i in seq(1,cluster.number,1)){\n        points(parameters[i,\"lambda\"],  weights[i], col= colors[i])\n      }\n    }\n  }\n  myplot\n}\n\n\ncompute_weights <- function(rkvectors){\n  if (class(rkvectors) != \"matrix\"){\n    stop (paste (c(\"Invalid type of rkvectors: expected matrix, got \", class(rkvectors))))\n  }\n  categories <- seq(from = 1, to = ncol(rkvectors), by = 1)\n  weights <- sapply (categories, function (k){\n    rkvector = rkvectors[, k]\n    sum(rkvector)/length(rkvector)\n  })\n}\n\ncompute_rkvectors <- function(data, model = NULL, parameters, weights){\n  cluster.number = length(weights)\n  categories <- seq(from = 1, to = cluster.number, by = 1)\n  rkvectors <- sapply(categories, function(k){\n    rk <-sapply(names(data), function(nodename){\n      cat_probs <- sapply ( categories, function (cat) {\n        if (model == \"weibull\"){\n          lnL_dat <- lnlikelihood_weibull(data[[nodename]], parameters[cat,\"lambda\"], parameters[cat,\"p\"], fishy = TRUE)\n        }\n        else {\n          lnL_dat <- lnlikelihood_exp(data[[nodename]], parameters[cat,\"lambda\"], fishy = TRUE)\n        }\n        lnL <- lnL_dat[1]\n        weights[cat] * exp(lnL)\n      }\n      )\n      cat_probs[k]/sum(cat_probs)\n    })\n  })\n  rownames(rkvectors) <- names(data)\n  rkvectors\n}\n\n\n\ncompute_params_insane <- function(data, model = NULL, rkvectors, mutation_position = \"middle\", parallel = FALSE ){\n  cluster.number = ncol(rkvectors)\n  categories <- seq(from = 1, to = cluster.number, by = 1)\n  \n  if (parallel){\n    if (Sys.info()[\"sysname\"] == \"Windows\"){\n      count_cores <- detectCores() - 1\n      cl <- makeCluster(count_cores)\n      clusterExport(cl, list(\"data\", \"rkvectors\", \"mutation_position\", \"model\"), envir = environment())\n      clusterCall(cl, function() library(evolike))\n      func <-  parLapply\n    } else {\n      func <- mclapply\n      mc.cores <- cluster.number\n    }\n  } else {\n    func <- mysapply\n    mc.cores <- 0 # mock variable\n  }\n  \n  params_list <- func(categories, function(k){\n    k_params <- find_single_root(data = data, mutation_position=mutation_position, rkvector = rkvectors[, k], jack = FALSE, pack = \"rootsolve\", verbose=TRUE)\n    if (model == \"weibull\"){\n      c(k_params[\"lambda_weib_root\"], k_params[\"p_root\"])\n    } else {\n      c(k_params[\"lambda_exp_root\"])\n    }\n  }, mc.cores = mc.cores)\n  \n  if (parallel && Sys.info()[\"sysname\"] == \"Windows\"){\n    stopCluster(cl)\n  }\n  \n  if(model == \"weibull\"){\n    new_params <- matrix(unlist(params_list), ncol = 2, byrow = TRUE)\n    colnames(new_params) = c(\"lambda\", \"p\")\n  } else {\n    new_params <- matrix(unlist(params_list), ncol = 1, byrow = TRUE)\n    colnames(new_params) = c(\"lambda\")\n  }\n  \n  new_params\n}\n\nmysapply <- function(X, FUN, mc.cores = 1){\n  sapply(X, FUN)\n}\n\n\n\ncompute_params <- function(data, model = NULL, rkvectors, mutation_position = \"middle\"){\n  cluster.number = ncol(rkvectors)\n  categories <- seq(from = 1, to = cluster.number, by = 1)\n  \n  params_list <- sapply(categories, function(k){\n    k_params <- find_single_root(data = data, mutation_position=mutation_position, rkvector = rkvectors[, k], jack = FALSE, pack = \"rootsolve\", verbose=TRUE)\n    if (model == \"weibull\"){\n      c(k_params[\"lambda_weib_root\"], k_params[\"p_root\"])\n    } else {\n      c(k_params[\"lambda_exp_root\"])\n    }\n  })\n  \n  if(model == \"weibull\"){\n    new_params <- matrix(unlist(params_list), ncol = 2, byrow = TRUE)\n    colnames(new_params) = c(\"lambda\", \"p\")\n  } else {\n    new_params <- matrix(unlist(params_list), ncol = 1, byrow = TRUE)\n    colnames(new_params) = c(\"lambda\")\n  }\n  \n  new_params\n}\n\ncompute_model_lnL <- function(data, model = NULL, parameters, weights){\n  cluster.number = length(weights)\n  categories <- seq(from = 1, to = cluster.number, by = 1)\n\n    likelihood_vector <-sapply(names(data), function(nodename){\n      cat_probs <- sapply ( categories, function (cat) {\n        if (model == \"weibull\"){\n          lnL_dat <- lnlikelihood_weibull(data[[nodename]], parameters[cat,\"lambda\"], parameters[cat,\"p\"], fishy = TRUE)\n        }\n        else {\n          lnL_dat <- lnlikelihood_exp(data[[nodename]], parameters[cat,\"lambda\"], fishy = TRUE)\n        }\n        lnL <- lnL_dat[1]\n        weights[cat] * exp(lnL)\n      }\n      )\n      sum(cat_probs)\n    })\n  \n  lnL <- sum(log(likelihood_vector))\n\n}\n\n## EM: E - compute rk vectors and weights of each category\n##     M - given rk, compute new sets of parameters for each category\n\n\n\n\n\n\n\n\n\n\n### Procedures \n#prot <- \"h1\"\n#prot_data <-  read.csv(paste(c(getwd(), \"/input/\" ,prot,\"_for_LRT.csv\"), collapse=\"\"),stringsAsFactors=FALSE)  \n#splitted <- split(prot_data, list(prot_data$site, prot_data$ancestor_node), drop=TRUE)\n#params <-parameters(splitted, mutation_position = \"middle\",  filter = TRUE, jack = FALSE, pack = \"rootsolve\", verbose = FALSE)\n\n\n#params <- data.frame(matrix(unlist(params), nrow=length(params), byrow=T),stringsAsFactors=FALSE)\n#names(params) <- c(\"node\", \"lambda_exp_root\", \"lambda_weib_root\", \"p_root\", \"p_precision\" )\n#params <- transform(params, lambda_exp_root = as.numeric(lambda_exp_root), lambda_weib_root = as.numeric(lambda_weib_root), p_root = as.numeric(p_root), p_precision = as.numeric(p_precision))\n#filtered <-params[!is.na(params$p_precision) ,]\n#filtered <-filtered[filtered$p_precision< 1e-5  ,]\n##filtered <-filtered[filtered$p_root< 30  ,]\n#df <-filtered[,c(\"lambda_weib_root\", \"p_root\")]\n#plot(df$p_root, df$lambda_weib_root, main = \"n2\")\n#plot(df$p_root, df$lambda_weib_root, xlim = c(0, 1.5), ylim = c(0, 0.1), main = \"n2\")\n#h1_kmeans <-kmeans(df, 3)\n",
    "created" : 1460551453315.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1675096898",
    "id" : "C5603543",
    "lastKnownWriteTime" : 1464970753,
    "path" : "C:/Users/weidewind/workspace/evolike/R/EM.R",
    "project_path" : "R/EM.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}