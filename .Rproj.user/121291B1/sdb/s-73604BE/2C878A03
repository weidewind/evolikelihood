{
    "contents" : "list.of.packages <- c(\"scatterplot3d\")\nnew.packages <- setdiff(list.of.packages, installed.packages()[,\"Package\"])\nif(length(new.packages)) install.packages(new.packages, repos='http://cran.us.r-project.org')\n\n#Don’t use library() or require(). These modify the search path, affecting what functions are available from the global environment. \n#It’s better to use the DESCRIPTION to specify your package’s requirements\n#library(scatterplot3d)\n## equations for computing maximum likelihood estimators\n\n\n# maximum likelihood estimation for lambda (exponential distribution)\n\nlambda_derivative_exp <- function(parms){\n  data <- parms$data\n  rkvector <- parms$rkvector\n  if(is.null(rkvector)){\n    rkvector <- c(1)\n    names(rkvector) = names(data)\n  }\n  mutation_position <- parms$mutation_position\n # print (rkvector)\n # print (head(data))\n  D_vector <- compute_d_vector(data, rkvector)\n  D <- sum(D_vector)\n  \n # print (\"D\")\n # print (D)\n  \n  branch_vector <- sapply(names(data),  function (name){ #changed apply, 1 to sapply\n    with(supplier(data=data,  rkvector=rkvector, elm = name, mutation_position = mutation_position), {\n     # print (\"r\")\n     # print (r)\n     # print (str(no_events_branches))\n      apply_res <- apply( no_events_branches, 1,\n                          function(br){\n                            #print (\"br\")\n                           # print(class(br))\n                           # print (br[\"t_branch_start\"][[1]])\n                            tbeta1 <- as.numeric(br[\"t_branch_end\"])\n                            tbeta0 <- as.numeric(br[\"t_branch_start\"])\n                            #print ( tbeta1-tbeta0)\n                            tbeta1-tbeta0\n                          })\n      sum(apply_res)*r\n    })\n  })\n  \n # print (\"sum( branch_vector )\")\n # print (sum( branch_vector ))\n  \n  x <- D/sum( branch_vector )\n  x\n}\n\n\n# maximum likelihood estimation for lambda (weibull distribution)\n\nlambda_derivative_weib <- function (parms) {\n  \n  data <- parms$data\n  rkvector <- parms$rkvector\n  if(is.null(rkvector)){\n    rkvector <- c(1)\n    names(rkvector) = names(data)\n  }\n  p <- parms$p\n  mutation_position <- parms$mutation_position\n  \n\n  \n  D_vector <- compute_d_vector(data, rkvector)\n  D <- sum(D_vector)\n  \n  denominator_vector <- sapply(names(data), function (name){\n    with(supplier(data=data,  rkvector=rkvector, elm = name, mutation_position = mutation_position), {\n      apply_res <- p_denominator_vector(no_events_branches, p)\n      sum(apply_res)*r #changed to sum\n    })\n  })\n  \n  x <- (D/sum(denominator_vector))^(1/p)\n  x\n  \n}\n\nsupplier <- function (data,  rkvector, elm, mutation_position){\n  node_data <- data[[elm]]\n  r <- rkvector[elm]\n  if (mutation_position != \"start\" && mutation_position != \"end\" && mutation_position != \"middle\") {\n    stop('Value of mutation_position parameter must be either \"start\" or \"end\" or \"middle\"')\n  }\n  if (mutation_position == \"start\"){\n    no_events_branches = node_data[node_data[\"event_indicator\"]==0,]\n  }\n  else if (mutation_position == \"end\"){\n    no_events_branches = node_data\n  }\n  else if (mutation_position == \"middle\"){\n    no_events_branches <- node_data[node_data[\"event_indicator\"]==0,]\n    first_halves = node_data[node_data[\"event_indicator\"]==1,]\n    first_halves[,\"t_branch_end\"] <- ( first_halves[,\"t_branch_end\"]+ first_halves[,\"t_branch_start\"])/2\n    no_events_branches = rbind(no_events_branches, first_halves)\n  }\n  if (mutation_position == \"middle\"){\n    second_halves = node_data[node_data[\"event_indicator\"]==1,]\n    second_halves[,\"t_branch_start\"] <- ( second_halves[,\"t_branch_end\"]+ second_halves[,\"t_branch_start\"])/2\n    events_branches = second_halves\n  }\n  else {\n    events_branches = node_data[node_data[\"event_indicator\"]==1,]\n  }\n  \n  list(r = r, no_events_branches = no_events_branches, events_branches = events_branches)\n}\n\n\n\n# weibull equation (2) multiplied by p\n# Root is the maximum likelihood estimation for p\n# Can be used as model function for multiroot (draw=FALSE)\n# or for plotting derivative of loglikelihood function d(logL)/d(p) (weibull equation (2)) (draw=TRUE)\n\np_derivative <- function (x, parms, draw=FALSE) {\n  #data is always a list of dataframes (node_datas)\n\n  mutation_position <- parms$mutation_position\n  rkvector <- parms$rkvector\n  data <- parms$data\n  if(is.null(rkvector)){\n    rkvector <- c(1)\n    names(rkvector) = names(data)\n  }\n  \n\n\n D_vector <- compute_d_vector(data, rkvector)\n D <- sum(D_vector)\n \n \n numerator_vector <- sapply(names(data), function (name){\n   with(supplier(data=data,  rkvector=rkvector, elm = name, mutation_position = mutation_position), {\n      apply_res <- p_numerator_vector(no_events_branches, x)\n      sum(apply_res)*r #changed to sum \n  })\n })\n\n denominator_vector <- sapply(names(data), function (name){\n   with(supplier(data=data,  rkvector=rkvector, elm = name, mutation_position = mutation_position), {\n     apply_res <- p_denominator_vector(no_events_branches, x)\n     sum(apply_res)*r #changed to sum \n   })\n })\n\n talpha_vector <- sapply(names(data), function (name){\n   with(supplier(data=data,  rkvector=rkvector, elm = name, mutation_position = mutation_position), {\n     apply_res <- p_talpha_vector(events_branches, mutation_position)\n     sum(apply_res)*r #changed to sum \n   })\n })\n\n   \n f2 <- D*x*sum(numerator_vector)/sum(denominator_vector) - x*sum(talpha_vector) - D\n# if (is.nan(f2) || is.na(f2)){\n#   print (\"Achtung!\")\n#   print (x)\n#   print (sum(numerator_vector))\n#   print (sum(denominator_vector))\n#   print(sum(talpha_vector))\n# }\n# else {\n#   print (\"ok\")\n#   print (x)\n#   print (sum(numerator_vector))\n#   print (sum(denominator_vector))\n#   print(sum(talpha_vector))\n#   print (f2)\n# }\n #f2 <- Dk*sum(numerator_vector)/sum(denominator_vector) - sum(talpha_vector) - Dk/x\n  #print (f2)\n  if(draw){\n    f2\n  }\n  else {\n    c(F1 = f2)\n  }\n\n}\n\n\n# series of subfunctions for computing p derivative (first and second)\ncompute_d_vector <- function (data, rkvector){\n  D_vector <- sapply(names(data), function (elm){\n    node_data <- data[[elm]]\n    r <- rkvector[elm]\n    sum (node_data[\"event_indicator\"]) * r\n  })\n  D_vector\n}\n\n\np_numerator_vector <- function(no_events_branches, x){\n  apply_res <- apply( no_events_branches, 1, #changed apply, 1 to saplly\n                       function(elm){ \n                         if(!is.na(elm[\"event_indicator\"])){ #if (nrow(dataframe) == 0), <apply> still tries to apply the function to.. header? the list is not empty: it contains the header\n                           tbeta1 <- as.numeric(elm[\"t_branch_end\"])\n                           tbeta0 <- as.numeric(elm[\"t_branch_start\"])\n                           if (tbeta0 == 0){logtbeta0 <- 0} # mutation can't die before it's birth\n                           else {logtbeta0 <- log(tbeta0)}\n                           if (tbeta1 == 0 || tbeta1 == 1){ 0 } # from equation \n                           \n                           else {\n                             logtbeta1 <- log(tbeta1)\n                             logtbeta1*(tbeta1^x)*(1-(logtbeta0/logtbeta1)*((tbeta0/tbeta1)^x))\n                           }\n                         }  \n                         else { 0 }\n                       })\n  as.vector(apply_res) #changed to as.vector()\n}\n\np_denominator_vector <-function(no_events_branches, x){\n  apply_res <- apply( no_events_branches, 1, #changed apply, 1 to saplly\n                       function(elm){\n                         if(!is.na(elm[\"event_indicator\"])){\n                           tbeta1 <- as.numeric(elm[\"t_branch_end\"])\n                           tbeta0 <- as.numeric(elm[\"t_branch_start\"])\n                           if (tbeta1 == 0) { 0 }\n                           else {  \n                             (tbeta1^x)*(1-(tbeta0/tbeta1)^x)\n                           }\n                         }\n                         else {0}\n                       })\n  as.vector(apply_res ) #changed to as.vector()\n}\n\np_talpha_vector <- function(events_branches, mutation_position){\n  apply_res <- apply( events_branches, 1, #changed apply, 1 to saplly\n                       function(elm){\n                         if(!is.na(elm[\"event_indicator\"])){ #if (nrow(dataframe) == 0), apply still tries to apply the function to.. header? the list is not empty: it contains the header\n                           if (mutation_position == \"start\"){talpha <- as.numeric(elm[\"t_branch_start\"])}\n                           else if (mutation_position == \"end\"){talpha <- as.numeric(elm[\"t_branch_end\"])}\n                           else if (mutation_position == \"middle\"){talpha <- as.numeric(elm[\"t_branch_start\"])} #since events_branches already have start = middle of the branch\n                           else {stop('Value of mutation_position parameter must be either \"start\" or \"end\" or \"middle\"')}\n                           \n                           if (talpha == 0){logtalpha = 0}\n                           else {logtalpha = log(talpha)}\n                           logtalpha\n                         }\n                         else {0}\n                       })\n  as.vector(apply_res) #changed to as.vector()\n}\n\n##\n\n\n# jacobian (just a derivative) of p_derivative_mult function  \n\np_derivative_jacfunc <- function(x, parms){\n  node_data <- parms$node_data\n  mutation_position <- parms$mutation_position\n  if (mutation_position == \"start\"){\n    no_events_branches = node_data[node_data[\"event_indicator\"]==0,]\n  }\n  else if (mutation_position == \"end\"){\n    no_events_branches = node_data\n  }\n  else {\n    stop('Value of mutation_position parameter must be either \"start\" or \"end\"')\n  }\n  events_branches = node_data[node_data[\"event_indicator\"]==1,]\n  \n  D <- sum (node_data[\"event_indicator\"])\n  \n  u <- p_numerator_vector(no_events_branches, x)\n  \n  udot <- apply( no_events_branches, 1,\n                 function(elm){ \n                   if(!is.na(elm[\"event_indicator\"])){ #if (nrow(dataframe) == 0), <apply> still tries to apply the function to.. header? the list is not empty: it contains the header\n                     tbeta1 <- as.numeric(elm[\"t_branch_end\"])\n                     tbeta0 <- as.numeric(elm[\"t_branch_start\"])\n                     if (tbeta0 == 0){logtbeta0 <- 0} # mutation can't die before it's birth\n                     else {logtbeta0 <- log(tbeta0)}\n                     if (tbeta1 == 0 || tbeta1 == 1){ 0 } # from equation \n                     \n                     else {\n                       logtbeta1 <- log(tbeta1)\n                       (logtbeta1^2)*(tbeta1^x)*(1-(logtbeta0/logtbeta1)^2*((tbeta0/tbeta1)^x))\n                     }\n                   }  \n                   else { 0 }\n                 })\n  \n  v <- p_denominator_vector(no_events_branches, x)\n  \n  vdot <- apply( no_events_branches, 1,\n                 function(elm){\n                   if(!is.na(elm[\"event_indicator\"])){\n                     tbeta1 <- as.numeric(elm[\"t_branch_end\"])\n                     tbeta0 <- as.numeric(elm[\"t_branch_start\"])\n                     if (tbeta0 == 0){logtbeta0 <- 0} # mutation can't die before it's birth\n                     else {logtbeta0 <- log(tbeta0)}\n                     if (tbeta1 == 0 || tbeta1 == 1){ 0 } # from equation\n                     else { \n                       logtbeta1 <- log(tbeta1)\n                       logtbeta1*(tbeta1^x)*(1-(logtbeta0/logtbeta1)*(tbeta0/tbeta1)^x)\n                     }\n                   }\n                   else {0}\n                 })\n  \n  \n  alphas <- p_talpha_vector(events_branches, mutation_position)\n  \n  \n  fdot <- D*x*(sum(udot)*sum(v) - sum(u)*sum(vdot))/(sum(v))^2 + D*sum(u)/sum(v)- sum(alphas) \n  matrix(fdot)\n}\n\n\n# plots partial derivative of loglikelihood function d(logL)/d(p) (weibull equation (2))  for given node_data \n\ndraw_p_derivative <- function(data, mutation_position = \"end\", rkvector, to = 20, by = 0.01){\n  #node_data <- splitted[[anc_node]]\n  anc_node <- names(data)\n  parms <- list(data = data, mutation_position = mutation_position, rkvector = rkvector)\n  y <- sapply(seq(from = -5, to = to, by = by), function (elm){p_derivative(elm,parms, draw=TRUE)})\n  plot( x = seq(from = -5, to = to, by = by), y, type = 'l', xlab = \"p\", ylab = \"f2\", axes=F, xaxt=\"n\", yaxt=\"n\", main = paste(c(anc_node, \" mut pos \", mutation_position)), ylim = c(-10, 5))\n  axis(1, pos=0)\n  axis(2, pos=0)\n  abline(v=0, h=0)\n}\n\ndraw_lambda_derivative <- function(data, mutation_position = \"end\"){\n  #node_data <- splitted[[anc_node]]\n  #node_data <- splitted[\"138.INTNODE2416\"]\n  anc_node <- names(data)\n \n  y <- sapply(seq(from = -5, to = 20, by = 0.05), function (elm){\n    parms <- list(data = data, mutation_position = mutation_position, p=elm)\n    lambda_derivative_weib(parms)})\n  plot( x = seq(from = -5, to = 20, by = 0.05), y, type = 'l', xlab = \"p\", ylab = \"lambda\", axes=F, xaxt=\"n\", yaxt=\"n\", main = anc_node, ylim = c(-0.01, 0.01), xlim = c(-1, 20))\n  axis(1, pos=0)\n  axis(2, pos=0)\n  abline(v=0, h=0)\n}\n\n#' @export\n#draw_lnlikelihood(splitted, \"169.INTNODE1233\") 165  node  INTNODE1457 ! 165  node  INTNODE1457 h1 238   INTNODE1364 site  169  node  INTNODE2065\ndraw_lnlikelihood <- function (data, nodename, to = 20, by = 0.01, mutation_position = \"middle\", fishy = TRUE){\n#data <- splitted\n  name <-nodename\n  node_data <- data[name]\n\n  p <- seq(from = 0, to = to, by = by)\n  lnlikelihood <- sapply(p, function (elm){\n      parms <- list(data = node_data, mutation_position = mutation_position, p=elm)\n      lambda <- lambda_derivative_weib(parms)\n      lnl <- lnlikelihood_weibull(node_data, lambda, elm, fishy = fishy)\n      lnl[\"lnL\"]\n  }\n  )\n\n  plot(p, lnlikelihood, ylab = \"lnlikelihood\", xlab =\"p\",  type = 'l', main = paste(c(name, \" fishy \", fishy, \" mut pos \", mutation_position)))\n  draw_p_derivative(node_data,  mutation_position= mutation_position, to=to, by=by)\n}\n\n#' @export\ndraw_hazard <-function(data, nodename, to = 20, by = 0.01, mutation_position = \"middle\", fishy = TRUE){\n  data=splitted\n  nodename = \"78.INTNODE4232\"\n  name <-nodename\n  node_data <- data[name]\n  \n  p <- seq(from = 0, to = 30, by = 0.5)\n  t <- seq(from = 0, to = 400, by = 5)\n # lambda <- sapply(p, function (elm){\n  #  parms <- list(data = node_data, mutation_position = mutation_position, p=elm)\n #   lambda <- lambda_derivative_weib(parms)\n # }\n # )\n  hazard <- sapply(t, function (time){\n    sapply(p, function (elm){\n      parms <- list(data = node_data, mutation_position = mutation_position, p=elm)\n      lambda <- lambda_derivative_weib(parms)\n      elm*(lambda^elm)*(time^(elm-1))\n    })\n  })\n hazard_time <-sapply(t, function (time){\n\n     parms <- list(data = node_data, mutation_position = mutation_position, p=30)\n     lambda <- lambda_derivative_weib(parms)\n     30*(lambda^30)*(time^(30-1))\n\n })\n # scatterplot3d()\n  persp(p, t, hazard, zlim=c(0,1),phi = 45, theta = 45,\n        xlab = \"p\", ylab = \"t\",\n        main = \"hazard\"\n  )\n \n plot(t, hazard_time, ylab = \"hazard\", xlab =\"t\",  type = 'l', ylim = c(0, 100), main = paste(c(name, \" fishy \", fishy, \" mut pos \", mutation_position)))\n # draw_p_derivative(node_data,  mutation_position= mutation_position, to=to, by=by)\n}\n\n",
    "created" : 1459936809519.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2040958863",
    "id" : "2C878A03",
    "lastKnownWriteTime" : 1465204470,
    "path" : "C:/Users/weidewind/workspace/evolike/R/MLE_functions.R",
    "project_path" : "R/MLE_functions.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}