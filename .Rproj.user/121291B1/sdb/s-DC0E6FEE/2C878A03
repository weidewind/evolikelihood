{
    "contents" : "## equations for computing maximum likelihood estimators\n\n\n# maximum likelihood estimation for lambda (exponential distribution)\n\nlambda_derivative_exp <- function(parms){\n  node_data <- parms$node_data\n  mutation_position <- parms$mutation_position\n  if (mutation_position == \"start\"){\n    no_events_branches = node_data[node_data[\"event_indicator\"]==0,]\n  }\n  else if (mutation_position == \"end\"){\n    no_events_branches = node_data\n  }\n  else {\n    stop('Value of mutation_position parameter must either \"start\" or \"end\"')\n  }\n  \n  apply_res <- apply( no_events_branches, 1,\n                      function(elm){\n                        tbeta1 <- as.numeric(elm[\"t_branch_end\"])\n                        tbeta0 <- as.numeric(elm[\"t_branch_start\"])\n                        tbeta1-tbeta0\n                      })\n  \n  x <- sum (node_data$event)/sum( apply_res )\n  x\n}\n\n\n# maximum likelihood estimation for lambda (weibull distribution)\n\nlambda_derivative_weib <- function (parms) {\n  node_data <- parms$node_data\n  p <- parms$p\n  mutation_position <- parms$mutation_position\n  if (mutation_position == \"start\"){\n    no_events_branches = node_data[node_data[\"event_indicator\"]==0,]\n  }\n  else if (mutation_position == \"end\"){\n    no_events_branches = node_data\n  }\n  else {\n    stop('Value of mutation_position parameter must either \"start\" or \"end\"')\n  }\n  \n  apply_res <- apply( no_events_branches, 1,\n                      function(elm){\n                        tbeta1 <- as.numeric(elm[\"t_branch_end\"])\n                        tbeta0 <- as.numeric(elm[\"t_branch_start\"])\n                        if (tbeta1 == 0){0}\n                        else {\n                          (tbeta1^p)*(1-(tbeta0/tbeta1)^p)\n                        }\n                      })\n  \n  x <- (sum (node_data$event)/sum( apply_res ))^(1/p)\n  x\n  \n}\n\n\n# weibull equation (2) multiplied by p\n# Root is the maximum likelihood estimation for p\n# Can be used as model function for multiroot (draw=FALSE)\n# or for plotting derivative of loglikelihood function d(logL)/d(p) (weibull equation (2)) (draw=TRUE)\n\np_derivative <- function (x, parms, draw=FALSE) {\n  \n  #checking input\n  if(is.null(parms$node_data)){\n    if(is.null(parms$data) || is.null(parms$rklist)){\n      stop (\"Parms list must contain either node_data, or data and rklist\")\n    }\n    else {group = TRUE} \n  }\n  else {\n    if(!is.null(parms$data) || !is.null(parms$rklist)){\n      stop (\"Parms list must contain either node_data, or data and rklist\")\n    }\n    else {group = FALSE} \n  }\n  ##\n  \n  if (group){\n    data <- parms$data\n    rklist <- parms$rklist\n  }\n  else {\n    data <- list(parms$node_data)\n    rklist <- c(1)\n    #node_data <- parms$node_data\n  }\n  mutation_position <- parms$mutation_position\n  ##\n  \n # for (node_data in category_data){\n \n D_vector <- sapply(names(data), function (elm){\n   node_data <- data[[elm]]\n   r <- rklist[rklist$node == elm, 2]\n   sum (node_data[\"event_indicator\"]) * r\n })\n \n Dk <- sum(D_vector)\n \n \n vector_1 <- sapply(names(data), function (elm){\n   if (mutation_position == \"start\"){\n     no_events_branches = node_data[node_data[\"event_indicator\"]==0,]\n   }\n   else if (mutation_position == \"end\"){\n     no_events_branches = node_data\n   }\n   else {\n     stop('Value of mutation_position parameter must be either \"start\" or \"end\"')\n   }\n   events_branches = node_data[node_data[\"event_indicator\"]==1,]\n   apply_res <- apply( no_events_branches, 1,\n                        function(elm){ \n                          if(!is.na(elm[\"event_indicator\"])){ #if (nrow(dataframe) == 0), <apply> still tries to apply the function to.. header? the list is not empty: it contains the header\n                            tbeta1 <- as.numeric(elm[\"t_branch_end\"])\n                            tbeta0 <- as.numeric(elm[\"t_branch_start\"])\n                            if (tbeta0 == 0){logtbeta0 <- 0} # mutation can't die before it's birth\n                            else {logtbeta0 <- log(tbeta0)}\n                            if (tbeta1 == 0 || tbeta1 == 1){ 0 } # from equation \n                            \n                            else {\n                              logtbeta1 <- log(tbeta1)\n                              logtbeta1*(tbeta1^x)*(1-(logtbeta0/logtbeta1)*((tbeta0/tbeta1)^x))\n                            }\n                          }  \n                          else { 0 }\n                        })\n }\n   \n   \n   \n   \n    if (mutation_position == \"start\"){\n      no_events_branches = node_data[node_data[\"event_indicator\"]==0,]\n    }\n    else if (mutation_position == \"end\"){\n      no_events_branches = node_data\n    }\n    else {\n      stop('Value of mutation_position parameter must be either \"start\" or \"end\"')\n    }\n    events_branches = node_data[node_data[\"event_indicator\"]==1,]\n  \n\n    D <- sum (node_data[\"event_indicator\"])\n  \n    apply_res1 <- p_numerator_vector(no_events_branches, x)\n  \n    apply_res2 <- p_denominator_vector(no_events_branches, x)\n  \n    apply_res3 <- p_talpha_vector(events_branches)\n  \n # }\n  \n  f2 <- D*x*sum( apply_res1 )/sum( apply_res2 ) - x*sum( apply_res3 ) - D\n  \n  if(draw){\n    f2\n  }\n  else {\n    c(F1 = f2)\n  }\n  \n}\n\n\n# series of subfunctions for computing p derivative (first and second)\np_numerator_vector <- function(no_events_branches, x){\n  apply_res <- apply( no_events_branches, 1,\n                       function(elm){ \n                         if(!is.na(elm[\"event_indicator\"])){ #if (nrow(dataframe) == 0), <apply> still tries to apply the function to.. header? the list is not empty: it contains the header\n                           tbeta1 <- as.numeric(elm[\"t_branch_end\"])\n                           tbeta0 <- as.numeric(elm[\"t_branch_start\"])\n                           if (tbeta0 == 0){logtbeta0 <- 0} # mutation can't die before it's birth\n                           else {logtbeta0 <- log(tbeta0)}\n                           if (tbeta1 == 0 || tbeta1 == 1){ 0 } # from equation \n                           \n                           else {\n                             logtbeta1 <- log(tbeta1)\n                             logtbeta1*(tbeta1^x)*(1-(logtbeta0/logtbeta1)*((tbeta0/tbeta1)^x))\n                           }\n                         }  \n                         else { 0 }\n                       })\n  apply_res\n}\n\np_denominator_vector <-function(no_events_branches, x){\n  apply_res <- apply( no_events_branches, 1,\n                       function(elm){\n                         if(!is.na(elm[\"event_indicator\"])){\n                           tbeta1 <- as.numeric(elm[\"t_branch_end\"])\n                           tbeta0 <- as.numeric(elm[\"t_branch_start\"])\n                           if (tbeta1 == 0) { 0 }\n                           else {  \n                             (tbeta1^x)*(1-(tbeta0/tbeta1)^x)\n                           }\n                         }\n                         else {0}\n                       })\n  apply_res \n}\n\np_talpha_vector <- function(events_branches){\n  apply_res <- apply( events_branches, 1,\n                       function(elm){\n                         if(!is.na(elm[\"event_indicator\"])){ #if (nrow(dataframe) == 0), apply still tries to apply the function to.. header? the list is not empty: it contains the header\n                           if (mutation_position == \"start\"){talpha <- as.numeric(elm[\"t_branch_start\"])}\n                           else if (mutation_position == \"end\"){talpha <- as.numeric(elm[\"t_branch_end\"])}\n                           else {stop('Value of mutation_position parameter must be either \"start\" or \"end\"')}\n                           \n                           if (talpha == 0){logtalpha = 0}\n                           else {logtalpha = log(talpha)}\n                           logtalpha\n                         }\n                         else {0}\n                       })\n  apply_res\n}\n\n##\n\n\n# jacobian (just a derivative) of p_derivative_mult function  \n\np_derivative_jacfunc <- function(x, parms){\n  node_data <- parms$node_data\n  mutation_position <- parms$mutation_position\n  if (mutation_position == \"start\"){\n    no_events_branches = node_data[node_data[\"event_indicator\"]==0,]\n  }\n  else if (mutation_position == \"end\"){\n    no_events_branches = node_data\n  }\n  else {\n    stop('Value of mutation_position parameter must be either \"start\" or \"end\"')\n  }\n  events_branches = node_data[node_data[\"event_indicator\"]==1,]\n  \n  D <- sum (node_data[\"event_indicator\"])\n  \n  u <- p_numerator_vector(no_events_branches, x)\n  \n  udot <- apply( no_events_branches, 1,\n                 function(elm){ \n                   if(!is.na(elm[\"event_indicator\"])){ #if (nrow(dataframe) == 0), <apply> still tries to apply the function to.. header? the list is not empty: it contains the header\n                     tbeta1 <- as.numeric(elm[\"t_branch_end\"])\n                     tbeta0 <- as.numeric(elm[\"t_branch_start\"])\n                     if (tbeta0 == 0){logtbeta0 <- 0} # mutation can't die before it's birth\n                     else {logtbeta0 <- log(tbeta0)}\n                     if (tbeta1 == 0 || tbeta1 == 1){ 0 } # from equation \n                     \n                     else {\n                       logtbeta1 <- log(tbeta1)\n                       (logtbeta1^2)*(tbeta1^x)*(1-(logtbeta0/logtbeta1)^2*((tbeta0/tbeta1)^x))\n                     }\n                   }  \n                   else { 0 }\n                 })\n  \n  v <- p_denominator_vector(no_events_branches, x)\n  \n  vdot <- apply( no_events_branches, 1,\n                 function(elm){\n                   if(!is.na(elm[\"event_indicator\"])){\n                     tbeta1 <- as.numeric(elm[\"t_branch_end\"])\n                     tbeta0 <- as.numeric(elm[\"t_branch_start\"])\n                     if (tbeta0 == 0){logtbeta0 <- 0} # mutation can't die before it's birth\n                     else {logtbeta0 <- log(tbeta0)}\n                     if (tbeta1 == 0 || tbeta1 == 1){ 0 } # from equation\n                     else { \n                       logtbeta1 <- log(tbeta1)\n                       logtbeta1*(tbeta1^x)*(1-(logtbeta0/logtbeta1)*(tbeta0/tbeta1)^x)\n                     }\n                   }\n                   else {0}\n                 })\n  \n  \n  alphas <- p_talpha_vector(events_branches)\n  \n  \n  fdot <- D*x*(sum(udot)*sum(v) - sum(u)*sum(vdot))/(sum(v))^2 + D*sum(u)/sum(v)- sum(alphas) \n  matrix(fdot)\n}\n\n\n# plots partial derivative of loglikelihood function d(logL)/d(p) (weibull equation (2))  for given node_data \n\ndraw_p_derivative <- function(node_data, mutation_position = \"end\"){\n  #node_data <- splitted[[anc_node]]\n  parms <- list(node_data = node_data, mutation_position)\n  y <- sapply(seq(from = -5, to = 5, by = 0.05), function (elm){p_derivative(elm,parms, draw=TRUE)})\n  plot( x = seq(from = -5, to = 5, by = 0.05), y, type = 'l', xlab = \"p\", ylab = \"f2\", axes=F, xaxt=\"n\", yaxt=\"n\", main = anc_node, ylim = c(-10, 5))\n  axis(1, pos=0)\n  axis(2, pos=0)\n  abline(v=0, h=0)\n}\n",
    "created" : 1459936809519.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3443282578",
    "id" : "2C878A03",
    "lastKnownWriteTime" : 1460464991,
    "path" : "C:/Users/weidewind/workspace/evolikelihood/R/MLE_functions.R",
    "project_path" : "R/MLE_functions.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}