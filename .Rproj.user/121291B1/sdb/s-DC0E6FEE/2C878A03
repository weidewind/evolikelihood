{
    "contents" : "install.packages(\"plotly\")\n## equations for computing maximum likelihood estimators\n\n\n# maximum likelihood estimation for lambda (exponential distribution)\n\nlambda_derivative_exp <- function(parms){\n  data <- parms$data\n  rkvector <- parms$rkvector\n  if(is.null(rkvector)){\n    rkvector <- c(1)\n    names(rkvector) = names(data)\n  }\n  mutation_position <- parms$mutation_position\n  \n  \n  D_vector <- compute_d_vector(data, rkvector)\n  D <- sum(D_vector)\n  \n  branch_vector <- sapply(names(data), function (name){\n    with(supplier(data=data,  rkvector=rkvector, elm = name, mutation_position = mutation_position), {\n      apply_res <- apply( no_events_branches, 1,\n                          function(br){\n                            tbeta1 <- as.numeric(br[\"t_branch_end\"])\n                            tbeta0 <- as.numeric(br[\"t_branch_start\"])\n                            tbeta1-tbeta0\n                          })\n      apply_res*r\n    })\n  })\n\n  \n  x <- D/sum( branch_vector )\n  x\n}\n\n\n# maximum likelihood estimation for lambda (weibull distribution)\n\nlambda_derivative_weib <- function (parms) {\n  \n  data <- parms$data\n  rkvector <- parms$rkvector\n  if(is.null(rkvector)){\n    rkvector <- c(1)\n    names(rkvector) = names(data)\n  }\n  p <- parms$p\n  mutation_position <- parms$mutation_position\n  \n\n  \n  D_vector <- compute_d_vector(data, rkvector)\n  D <- sum(D_vector)\n  \n  denominator_vector <- sapply(names(data), function (name){\n    with(supplier(data=data,  rkvector=rkvector, elm = name, mutation_position = mutation_position), {\n      apply_res <- p_denominator_vector(no_events_branches, p)\n      apply_res*r\n    })\n  })\n  \n  x <- (D/sum(denominator_vector))^(1/p)\n  x\n  \n}\n\nsupplier <- function (data,  rkvector, elm, mutation_position){\n  node_data <- data[[elm]]\n  r <- rkvector[elm]\n  if (mutation_position != \"start\" && mutation_position != \"end\" && mutation_position != \"middle\") {\n    stop('Value of mutation_position parameter must be either \"start\" or \"end\" or \"middle\"')\n  }\n  if (mutation_position == \"start\"){\n    no_events_branches = node_data[node_data[\"event_indicator\"]==0,]\n  }\n  else if (mutation_position == \"end\"){\n    no_events_branches = node_data\n  }\n  else if (mutation_position == \"middle\"){\n    no_events_branches = node_data[node_data[\"event_indicator\"]==0,]\n    first_halves = node_data[node_data[\"event_indicator\"]==1,]\n    first_halves[,\"t_branch_end\"] <- ( first_halves[,\"t_branch_end\"]+ first_halves[,\"t_branch_start\"])/2\n    no_events_branches = rbind(no_events_branches, first_halves)\n  }\n  if (mutation_position == \"middle\"){\n    second_halves = node_data[node_data[\"event_indicator\"]==1,]\n    second_halves[,\"t_branch_start\"] <- ( second_halves[,\"t_branch_end\"]+ second_halves[,\"t_branch_start\"])/2\n    events_branches = second_halves\n  }\n  else {\n    events_branches = node_data[node_data[\"event_indicator\"]==1,]\n  }\n  \n  list(r = r, no_events_branches = no_events_branches, events_branches = events_branches)\n}\n\n\n\n# weibull equation (2) multiplied by p\n# Root is the maximum likelihood estimation for p\n# Can be used as model function for multiroot (draw=FALSE)\n# or for plotting derivative of loglikelihood function d(logL)/d(p) (weibull equation (2)) (draw=TRUE)\n\np_derivative <- function (x, parms, draw=FALSE) {\n  #data is always a list of dataframes (node_datas)\n\n  mutation_position <- parms$mutation_position\n  rkvector <- parms$rkvector\n  data <- parms$data\n  if(is.null(rkvector)){\n    rkvector <- c(1)\n    names(rkvector) = names(data)\n  }\n  \n\n\n D_vector <- compute_d_vector(data, rkvector)\n D <- sum(D_vector)\n \n \n numerator_vector <- sapply(names(data), function (name){\n   with(supplier(data=data,  rkvector=rkvector, elm = name, mutation_position = mutation_position), {\n      apply_res <- p_numerator_vector(no_events_branches, x)\n      apply_res*r\n  })\n })\n\n denominator_vector <- sapply(names(data), function (name){\n   with(supplier(data=data,  rkvector=rkvector, elm = name, mutation_position = mutation_position), {\n     apply_res <- p_denominator_vector(no_events_branches, x)\n     apply_res*r\n   })\n })\n\n talpha_vector <- sapply(names(data), function (name){\n   with(supplier(data=data,  rkvector=rkvector, elm = name, mutation_position = mutation_position), {\n     apply_res <- p_talpha_vector(events_branches, mutation_position)\n     apply_res*r\n   })\n })\n\n   \n f2 <- D*x*sum(numerator_vector)/sum(denominator_vector) - x*sum(talpha_vector) - D\n #f2 <- Dk*sum(numerator_vector)/sum(denominator_vector) - sum(talpha_vector) - Dk/x\n  print (f2)\n  if(draw){\n    f2\n  }\n  else {\n    c(F1 = f2)\n  }\n\n}\n\n\n# series of subfunctions for computing p derivative (first and second)\ncompute_d_vector <- function (data, rkvector){\n  D_vector <- sapply(names(data), function (elm){\n    node_data <- data[[elm]]\n    r <- rkvector[elm]\n    sum (node_data[\"event_indicator\"]) * r\n  })\n  D_vector\n}\n\n\np_numerator_vector <- function(no_events_branches, x){\n  apply_res <- apply( no_events_branches, 1,\n                       function(elm){ \n                         if(!is.na(elm[\"event_indicator\"])){ #if (nrow(dataframe) == 0), <apply> still tries to apply the function to.. header? the list is not empty: it contains the header\n                           tbeta1 <- as.numeric(elm[\"t_branch_end\"])\n                           tbeta0 <- as.numeric(elm[\"t_branch_start\"])\n                           if (tbeta0 == 0){logtbeta0 <- 0} # mutation can't die before it's birth\n                           else {logtbeta0 <- log(tbeta0)}\n                           if (tbeta1 == 0 || tbeta1 == 1){ 0 } # from equation \n                           \n                           else {\n                             logtbeta1 <- log(tbeta1)\n                             logtbeta1*(tbeta1^x)*(1-(logtbeta0/logtbeta1)*((tbeta0/tbeta1)^x))\n                           }\n                         }  \n                         else { 0 }\n                       })\n  apply_res\n}\n\np_denominator_vector <-function(no_events_branches, x){\n  apply_res <- apply( no_events_branches, 1,\n                       function(elm){\n                         if(!is.na(elm[\"event_indicator\"])){\n                           tbeta1 <- as.numeric(elm[\"t_branch_end\"])\n                           tbeta0 <- as.numeric(elm[\"t_branch_start\"])\n                           if (tbeta1 == 0) { 0 }\n                           else {  \n                             (tbeta1^x)*(1-(tbeta0/tbeta1)^x)\n                           }\n                         }\n                         else {0}\n                       })\n  apply_res \n}\n\np_talpha_vector <- function(events_branches, mutation_position){\n  apply_res <- apply( events_branches, 1,\n                       function(elm){\n                         if(!is.na(elm[\"event_indicator\"])){ #if (nrow(dataframe) == 0), apply still tries to apply the function to.. header? the list is not empty: it contains the header\n                           if (mutation_position == \"start\"){talpha <- as.numeric(elm[\"t_branch_start\"])}\n                           else if (mutation_position == \"end\"){talpha <- as.numeric(elm[\"t_branch_end\"])}\n                           else if (mutation_position == \"middle\"){talpha <- as.numeric(elm[\"t_branch_start\"])} #since events_branches already have start = middle of the branch\n                           else {stop('Value of mutation_position parameter must be either \"start\" or \"end\" or \"middle\"')}\n                           \n                           if (talpha == 0){logtalpha = 0}\n                           else {logtalpha = log(talpha)}\n                           logtalpha\n                         }\n                         else {0}\n                       })\n  apply_res\n}\n\n##\n\n\n# jacobian (just a derivative) of p_derivative_mult function  \n\np_derivative_jacfunc <- function(x, parms){\n  node_data <- parms$node_data\n  mutation_position <- parms$mutation_position\n  if (mutation_position == \"start\"){\n    no_events_branches = node_data[node_data[\"event_indicator\"]==0,]\n  }\n  else if (mutation_position == \"end\"){\n    no_events_branches = node_data\n  }\n  else {\n    stop('Value of mutation_position parameter must be either \"start\" or \"end\"')\n  }\n  events_branches = node_data[node_data[\"event_indicator\"]==1,]\n  \n  D <- sum (node_data[\"event_indicator\"])\n  \n  u <- p_numerator_vector(no_events_branches, x)\n  \n  udot <- apply( no_events_branches, 1,\n                 function(elm){ \n                   if(!is.na(elm[\"event_indicator\"])){ #if (nrow(dataframe) == 0), <apply> still tries to apply the function to.. header? the list is not empty: it contains the header\n                     tbeta1 <- as.numeric(elm[\"t_branch_end\"])\n                     tbeta0 <- as.numeric(elm[\"t_branch_start\"])\n                     if (tbeta0 == 0){logtbeta0 <- 0} # mutation can't die before it's birth\n                     else {logtbeta0 <- log(tbeta0)}\n                     if (tbeta1 == 0 || tbeta1 == 1){ 0 } # from equation \n                     \n                     else {\n                       logtbeta1 <- log(tbeta1)\n                       (logtbeta1^2)*(tbeta1^x)*(1-(logtbeta0/logtbeta1)^2*((tbeta0/tbeta1)^x))\n                     }\n                   }  \n                   else { 0 }\n                 })\n  \n  v <- p_denominator_vector(no_events_branches, x)\n  \n  vdot <- apply( no_events_branches, 1,\n                 function(elm){\n                   if(!is.na(elm[\"event_indicator\"])){\n                     tbeta1 <- as.numeric(elm[\"t_branch_end\"])\n                     tbeta0 <- as.numeric(elm[\"t_branch_start\"])\n                     if (tbeta0 == 0){logtbeta0 <- 0} # mutation can't die before it's birth\n                     else {logtbeta0 <- log(tbeta0)}\n                     if (tbeta1 == 0 || tbeta1 == 1){ 0 } # from equation\n                     else { \n                       logtbeta1 <- log(tbeta1)\n                       logtbeta1*(tbeta1^x)*(1-(logtbeta0/logtbeta1)*(tbeta0/tbeta1)^x)\n                     }\n                   }\n                   else {0}\n                 })\n  \n  \n  alphas <- p_talpha_vector(events_branches, mutation_position)\n  \n  \n  fdot <- D*x*(sum(udot)*sum(v) - sum(u)*sum(vdot))/(sum(v))^2 + D*sum(u)/sum(v)- sum(alphas) \n  matrix(fdot)\n}\n\n\n# plots partial derivative of loglikelihood function d(logL)/d(p) (weibull equation (2))  for given node_data \n\ndraw_p_derivative <- function(data, mutation_position = \"end\"){\n  #node_data <- splitted[[anc_node]]\n  anc_node <- names(data)\n  parms <- list(data = data, mutation_position = mutation_position)\n  y <- sapply(seq(from = -5, to = 300, by = 0.5), function (elm){p_derivative(elm,parms, draw=TRUE)})\n  plot( x = seq(from = -5, to = 300, by = 0.5), y, type = 'l', xlab = \"p\", ylab = \"f2\", axes=F, xaxt=\"n\", yaxt=\"n\", main = paste(c(anc_node, \" mut pos \", mutation_position)), ylim = c(-10, 5))\n  axis(1, pos=0)\n  axis(2, pos=0)\n  abline(v=0, h=0)\n}\n\ndraw_lambda_derivative <- function(data, mutation_position = \"end\"){\n  #node_data <- splitted[[anc_node]]\n  #node_data <- splitted[\"138.INTNODE2416\"]\n  anc_node <- names(data)\n \n  y <- sapply(seq(from = -5, to = 20, by = 0.05), function (elm){\n    parms <- list(data = data, mutation_position = mutation_position, p=elm)\n    lambda_derivative_weib(parms)})\n  plot( x = seq(from = -5, to = 20, by = 0.05), y, type = 'l', xlab = \"p\", ylab = \"lambda\", axes=F, xaxt=\"n\", yaxt=\"n\", main = anc_node, ylim = c(-0.01, 0.01), xlim = c(-1, 20))\n  axis(1, pos=0)\n  axis(2, pos=0)\n  abline(v=0, h=0)\n}\n\nname <-\"36.INTNODE1224\"\nnode_data <- splitted[name]\nfishy <- TRUE\nmutation_position = \"middle\"\n\np <- seq(from = 0.025, to = 250, by = 1)\n#lambda <- sapply(p, function (elm){\n#  parms <- list(data = node_data, mutation_position = mutation_position, p=elm)\n#  lambda_derivative_weib(parms)})\nlnlikelihood <- sapply(p, function (elm){\n      parms <- list(data = node_data, mutation_position = mutation_position, p=elm)\n      lambda <- lambda_derivative_weib(parms)\n      lnl <- lnlikelihood_weibull(node_data, lambda, elm, fishy = fishy)\n      lnl[\"lnL\"]\n  }\n  )\n#surf <- cbind(p, lambda, lnlikelihood )\n#plot_ly(x = p, y = lambda, z = lnlikelihood, type = \"scatter3D\")\n#scatterplot3d(p, lambda, lnlikelihood)\nplot(p, lnlikelihood, main = paste(c(name, \" fishy \", fishy, \" mut pos \", mutation_position)))\ndraw_p_derivative(node_data,  mutation_position= mutation_position)\n\n\n",
    "created" : 1459936809519.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3819017983",
    "id" : "2C878A03",
    "lastKnownWriteTime" : 1460797331,
    "path" : "C:/Users/weidewind/workspace/evolikelihood/R/MLE_functions.R",
    "project_path" : "R/MLE_functions.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}