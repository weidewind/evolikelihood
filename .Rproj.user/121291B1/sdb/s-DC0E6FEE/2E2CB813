{
    "contents" : "install.packages(\"rootSolve\")\nlibrary(\"rootSolve\")\n\n## Functions\n\n# weibull equation 1\nlambda_derivative <- function (x, parms) {\n  node_data <- parms$node_data\n  p <- parms$p\n  mutation_position <- parms$mutation_position\n  if (mutation_position == \"start\"){\n    no_events_branches = node_data[node_data[\"event_indicator\"]==0,]\n  }\n  else if (mutation_position == \"end\"){\n    no_events_branches = node_data\n  }\n  else {\n    stop('Value of mutation_position parameter must be either \"start\" or \"end\"')\n  }\n  f1 <- (- sum (node_data$event)) + ( x^p )*\n    sum( apply( no_events_branches, 1,\n                function(elm){            \n                  (as.numeric(elm[\"t_branch_end\"]))^p-(as.numeric(elm[\"t_branch_start\"]))^p\n                })) \n\n    c(F1 = f1)\n  \n  \n}\n\n# weibull equation 2\np_derivative <- function (x, parms) {\n    #node_data <- parms\n    node_data <- parms$node_data\n    mutation_position <- parms$mutation_position\n    if (mutation_position == \"start\"){\n      no_events_branches = node_data[node_data[\"event_indicator\"]==0,]\n    }\n    else if (mutation_position == \"end\"){\n      no_events_branches = node_data\n    }\n    else {\n      stop('Value of mutation_position parameter must either \"start\" or \"end\"')\n    }\n    D <- sum (node_data[\"event_indicator\"])\n    f2 <- D*sum( apply( no_events_branches, 1,\n                        function(elm){ \n                          if(!is.na(elm[\"event_indicator\"])){ #if (nrow(dataframe) == 0), <apply> still tries to apply the function to.. header? the list is not empty: it contains the header\n                              tbeta1 <- as.numeric(elm[\"t_branch_end\"])\n                              tbeta0 <- as.numeric(elm[\"t_branch_start\"])\n                              if (tbeta0 == 0){logtbeta0 = 0} # mutation can't die before it's birth\n                              else {logtbeta0 = log(tbeta0)}\n                              if (tbeta1 == 0){logtbeta1 = 0}\n                              else {logtbeta1 = log(tbeta1)}\n                              logtbeta1*tbeta1^x-logtbeta0*tbeta0^x\n                          }\n                          else {0}\n                        }))/\n      sum ( apply( no_events_branches, 1,\n                  function(elm){\n                    if(!is.na(elm[\"event_indicator\"])){\n                        tbeta1 <- as.numeric(elm[\"t_branch_end\"])\n                        tbeta0 <- as.numeric(elm[\"t_branch_start\"])\n                        tbeta1^x-tbeta0^x\n                    }\n                    else {0}\n                  })) - \n      sum ( apply( node_data[node_data[\"event_indicator\"]==1,], 1,\n                  function(elm){\n                        if(!is.na(elm[\"event_indicator\"])){ #if (nrow(dataframe) == 0), apply still tries to apply the function to.. header? the list is not empty: it contains the header\n                            talpha0 <- as.numeric(elm[\"t_branch_start\"])\n                            if (talpha0 == 0){logtalpha0 = 0}\n                            else {logtalpha0 = log(talpha0)}\n                            logtalpha0\n                        }\n                        else {0}\n                    }\n                  ))\n\n       - D/x\n    #print (\"----f2----\")\n    #print (str(f2))\n    c(F1 = f2)\n  \n  \n}\n\n\n\n\n# weibull equation 1 modified\n#lambda_derivative_mod <- function (x, parms) {\nlambda_derivative_mod <- function (parms) {\n  node_data <- parms$node_data\n  p <- parms$p\n  mutation_position <- parms$mutation_position\n  if (mutation_position == \"start\"){\n    no_events_branches = node_data[node_data[\"event_indicator\"]==0,]\n  }\n  else if (mutation_position == \"end\"){\n    no_events_branches = node_data\n  }\n  else {\n    stop('Value of mutation_position parameter must either \"start\" or \"end\"')\n  }\n  \n  apply_res <- apply( no_events_branches, 1,\n                      function(elm){\n                        tbeta1 <- as.numeric(elm[\"t_branch_end\"])\n                        tbeta0 <- as.numeric(elm[\"t_branch_start\"])\n                        if (tbeta1 == 0){0}\n                        else {\n                          (tbeta1^p)*(1-(tbeta0/tbeta1)^p)\n                        }\n                      })\n # f1 <- (- sum (node_data$event)) + ( x^p )*sum( apply_res ) \n  \n x <- (sum (node_data$event)/sum( apply_res ))^(1/p)\n x\n # c(F1 = f1)\n  \n  \n}\n\n\n# weibull equation 2 modified\np_derivative_mod <- function (x, parms) {\n\n  node_data <- parms$node_data\n  mutation_position <- parms$mutation_position\n  if (mutation_position == \"start\"){\n    no_events_branches = node_data[node_data[\"event_indicator\"]==0,]\n  }\n  else if (mutation_position == \"end\"){\n    no_events_branches = node_data\n  }\n  else {\n    stop('Value of mutation_position parameter must be either \"start\" or \"end\"')\n  }\n  \n  D <- sum (node_data[\"event_indicator\"])\n  \n  apply_res1 <- apply( no_events_branches, 1,\n           function(elm){ \n             if(!is.na(elm[\"event_indicator\"])){ #if (nrow(dataframe) == 0), <apply> still tries to apply the function to.. header? the list is not empty: it contains the header\n               tbeta1 <- as.numeric(elm[\"t_branch_end\"])\n               tbeta0 <- as.numeric(elm[\"t_branch_start\"])\n               if (tbeta0 == 0){logtbeta0 <- 0} # mutation can't die before it's birth\n               else {logtbeta0 <- log(tbeta0)}\n               if (tbeta1 == 0 || tbeta1 == 1){ 0 } # from equation \n               \n               else {\n                 logtbeta1 <- log(tbeta1)\n                 logtbeta1*(tbeta1^x)*(1-(logtbeta0/logtbeta1)*((tbeta0/tbeta1)^x))\n               }\n             }  \n             else { 0 }\n           })\n\n  apply_res2 <- apply( no_events_branches, 1,\n                       function(elm){\n                         if(!is.na(elm[\"event_indicator\"])){\n                           tbeta1 <- as.numeric(elm[\"t_branch_end\"])\n                           tbeta0 <- as.numeric(elm[\"t_branch_start\"])\n                           if (tbeta1 == 0) { 0 }\n                           else {  \n                             (tbeta1^x)*(1-(tbeta0/tbeta1)^x)\n                           }\n                         }\n                         else {0}\n                       })\n  \n  apply_res3 <- apply( node_data[node_data[\"event_indicator\"]==1,], 1,\n                       function(elm){\n                         if(!is.na(elm[\"event_indicator\"])){ #if (nrow(dataframe) == 0), apply still tries to apply the function to.. header? the list is not empty: it contains the header\n                           if (mutation_position == \"start\"){talpha <- as.numeric(elm[\"t_branch_start\"])}\n                           else if (mutation_position == \"end\"){talpha <- as.numeric(elm[\"t_branch_end\"])}\n                           else {stop('Value of mutation_position parameter must be either \"start\" or \"end\"')}\n                           \n                           if (talpha == 0){logtalpha = 0}\n                           else {logtalpha = log(talpha)}\n                           logtalpha\n                         }\n                         else {0}\n                       }\n  )\n  \n  \n  f2 <- D*x*sum( apply_res1 )/sum( apply_res2 ) - x*sum( apply_res3 ) - D\n\n  c(F1 = f2)\n  \n  \n}\n\n\np_derivative_jacfunc <- function(x, parms){\n  node_data <- parms$node_data\n  mutation_position <- parms$mutation_position\n  if (mutation_position == \"start\"){\n    no_events_branches = node_data[node_data[\"event_indicator\"]==0,]\n  }\n  else if (mutation_position == \"end\"){\n    no_events_branches = node_data\n  }\n  else {\n    stop('Value of mutation_position parameter must be either \"start\" or \"end\"')\n  }\n  \n  D <- sum (node_data[\"event_indicator\"])\n  \n  u <- <- apply( no_events_branches, 1,\n                 function(elm){ \n                   if(!is.na(elm[\"event_indicator\"])){ #if (nrow(dataframe) == 0), <apply> still tries to apply the function to.. header? the list is not empty: it contains the header\n                     tbeta1 <- as.numeric(elm[\"t_branch_end\"])\n                     tbeta0 <- as.numeric(elm[\"t_branch_start\"])\n                     if (tbeta0 == 0){logtbeta0 <- 0} # mutation can't die before it's birth\n                     else {logtbeta0 <- log(tbeta0)}\n                     if (tbeta1 == 0 || tbeta1 == 1){ 0 } # from equation \n                     \n                     else {\n                       logtbeta1 <- log(tbeta1)\n                       logtbeta1*(tbeta1^x)*(1-(logtbeta0/logtbeta1)*((tbeta0/tbeta1)^x))\n                     }\n                   }  \n                   else { 0 }\n                 })\n    \n  udot <- apply( no_events_branches, 1,\n                       function(elm){ \n                         if(!is.na(elm[\"event_indicator\"])){ #if (nrow(dataframe) == 0), <apply> still tries to apply the function to.. header? the list is not empty: it contains the header\n                           tbeta1 <- as.numeric(elm[\"t_branch_end\"])\n                           tbeta0 <- as.numeric(elm[\"t_branch_start\"])\n                           if (tbeta0 == 0){logtbeta0 <- 0} # mutation can't die before it's birth\n                           else {logtbeta0 <- log(tbeta0)}\n                           if (tbeta1 == 0 || tbeta1 == 1){ 0 } # from equation \n                           \n                           else {\n                             logtbeta1 <- log(tbeta1)\n                             (logtbeta1^2)*(tbeta1^x)*(1-(logtbeta0/logtbeta1)^2*((tbeta0/tbeta1)^x))\n                           }\n                         }  \n                         else { 0 }\n                       })\n  \n  v <- apply( no_events_branches, 1,\n                       function(elm){\n                         if(!is.na(elm[\"event_indicator\"])){\n                           tbeta1 <- as.numeric(elm[\"t_branch_end\"])\n                           tbeta0 <- as.numeric(elm[\"t_branch_start\"])\n                           if (tbeta1 == 0) { 0 }\n                           else {  \n                             (tbeta1^x)*(1-(tbeta0/tbeta1)^x)\n                           }\n                         }\n                         else {0}\n                       })\n  vdot <- apply( no_events_branches, 1,\n              function(elm){\n                if(!is.na(elm[\"event_indicator\"])){\n                  tbeta1 <- as.numeric(elm[\"t_branch_end\"])\n                  tbeta0 <- as.numeric(elm[\"t_branch_start\"])\n                  if (tbeta0 == 0){logtbeta0 <- 0} # mutation can't die before it's birth\n                  else {logtbeta0 <- log(tbeta0)}\n                  if (tbeta1 == 0 || tbeta1 == 1){ 0 } # from equation\n                  else { \n                    logtbeta1 <- log(tbeta1)\n                    logtbeta1*(tbeta1^x)*(1-(logtbeta0/logtbeta1)*(tbeta0/tbeta1)^x)\n                  }\n                }\n                else {0}\n              })\n  \n  alphas <- apply( node_data[node_data[\"event_indicator\"]==1,], 1,\n                       function(elm){\n                         if(!is.na(elm[\"event_indicator\"])){ #if (nrow(dataframe) == 0), apply still tries to apply the function to.. header? the list is not empty: it contains the header\n                           if (mutation_position == \"start\"){talpha <- as.numeric(elm[\"t_branch_start\"])}\n                           else if (mutation_position == \"end\"){talpha <- as.numeric(elm[\"t_branch_end\"])}\n                           else {stop('Value of mutation_position parameter must be either \"start\" or \"end\"')}\n                           \n                           if (talpha == 0){logtalpha = 0}\n                           else {logtalpha = log(talpha)}\n                           logtalpha\n                         }\n                         else {0}\n                       }\n  )\n  \n  \n  fdot <- D*x*(sum(udot)*sum(v) - sum(u)*sum(vdot))/(sum(v))^2 + D*sum(u)/sum(v)- sum(alphas) \n\n}\n\n#exponential d(lambda)likelihood\n#lambda_derivative_exp <- function(x, parms){\nlambda_derivative_exp <- function(parms){\n  node_data <- parms$node_data\n  mutation_position <- parms$mutation_position\n  if (mutation_position == \"start\"){\n    no_events_branches = node_data[node_data[\"event_indicator\"]==0,]\n  }\n  else if (mutation_position == \"end\"){\n    no_events_branches = node_data\n  }\n  else {\n    stop('Value of mutation_position parameter must either \"start\" or \"end\"')\n  }\n  \n  apply_res <- apply( no_events_branches, 1,\n                      function(elm){\n                        tbeta1 <- as.numeric(elm[\"t_branch_end\"])\n                        tbeta0 <- as.numeric(elm[\"t_branch_start\"])\n                        tbeta1-tbeta0\n                      })\n  #f1 <- x*sum( apply_res ) - sum (node_data$event)\n  \n  x <- sum (node_data$event)/sum( apply_res )\n  x\n  #c(F1 = f1)\n  \n  \n}\n\nfunction_p_derivative <- function(x, parms){\n  node_data <- parms$node_data\n  mutation_position <- parms$mutation_position\n  if (mutation_position == \"start\"){\n    no_events_branches = node_data[node_data[\"event_indicator\"]==0,]\n  }\n  else if (mutation_position == \"end\"){\n    no_events_branches = node_data\n  }\n  else {\n    stop('Value of mutation_position parameter must be either \"start\" or \"end\"')\n  }\n  \n # print (\"no_events_branches\")\n # print (str(no_events_branches))\n # print (class(no_events_branches))\n  \n  D <- sum (node_data[\"event_indicator\"])\n  \n  apply_res1 <- apply( no_events_branches, 1,\n                 function(elm){ \n                   if(!is.na(elm[\"event_indicator\"])){ #if (nrow(dataframe) == 0), <apply> still tries to apply the function to.. header? the list is not empty: it contains the header\n                     tbeta1 <- as.numeric(elm[\"t_branch_end\"])\n                     tbeta0 <- as.numeric(elm[\"t_branch_start\"])\n                     if (tbeta0 == 0){logtbeta0 <- 0} # mutation can't die before it's birth\n                     else {logtbeta0 <- log(tbeta0)}\n                     if (tbeta1 == 0 || tbeta1 == 1){ 0 } # from equation \n                     \n                     else {\n                       logtbeta1 <- log(tbeta1)\n                       logtbeta1*(tbeta1^x)*(1-(logtbeta0/logtbeta1)*((tbeta0/tbeta1)^x))\n                     }\n                   }  \n                   else { 0 }\n                 })\n  \n#  print (\"apply_res1\")\n#  print (\"---str---\")\n#  print (str(apply_res1))\n#  print (\"---class---\")\n#  print (class(apply_res1))\n#  print (\"---contents---\")\n#  print (apply_res1)\n  \n  apply_res2 <- apply( no_events_branches, 1,\n                       function(elm){\n                         if(!is.na(elm[\"event_indicator\"])){\n                           tbeta1 <- as.numeric(elm[\"t_branch_end\"])\n                           tbeta0 <- as.numeric(elm[\"t_branch_start\"])\n                           if (tbeta1 == 0) { 0 }\n                           else {  \n                             (tbeta1^x)*(1-(tbeta0/tbeta1)^x)\n                           }\n                         }\n                         else {0}\n                       })\n  \n#  print (\"apply_res2\")\n#  print (\"---str---\")\n#  print (str(apply_res2))\n#  print (\"---class---\")\n#  print (class(apply_res2))\n#  print (\"---contents---\")\n#  print (apply_res2)\n  \n  apply_res3 <- apply( node_data[node_data[\"event_indicator\"]==1,], 1,\n                       function(elm){\n                         \n                         if(!is.na(elm[\"event_indicator\"])){ #if (nrow(dataframe) == 0), apply still tries to apply the function to.. header? the list is not empty: it contains the header\n                            if (mutation_position == \"start\"){talpha <- as.numeric(elm[\"t_branch_start\"])}\n                            else if (mutation_position == \"end\"){talpha <- as.numeric(elm[\"t_branch_end\"])}\n                            else {stop('Value of mutation_position parameter must be either \"start\" or \"end\"')}\n\n                            if (talpha == 0){logtalpha = 0}\n                            else {logtalpha = log(talpha)}\n                            logtalpha\n                         }\n                         else {0}\n                       }\n  )\n  \n#  print (\"apply_res3\")\n#  print (\"---str---\")\n#  print (str(apply_res3))\n#  print (\"---class---\")\n#  print (class(apply_res3))\n#  print (\"---contents---\")\n#  print (apply_res3)\n  \n f2 <- x*D*sum( apply_res1 )/sum( apply_res2 ) - x*sum( apply_res3 ) - D\n\n  f2  \n  \n}\n\n\n\n\n## multiroot, finds only one root \nfind_single_root <- function(node_data, mutation_position){\n  if (sum(node_data$event) != 0){\n      print (node_data)\n      print (paste(\"site \", node_data[2,1], \" node \", node_data[2,2]))\n      print (paste(\"number of mutations \", sum(node_data$event)))\n      \n      pars <- list(node_data = node_data, mutation_position = mutation_position)\n    # solution_exp_lambda <- multiroot(f = lambda_derivative_exp, start = c(1), parms = pars)\n      lambda_exp_root <- lambda_derivative_exp(pars)\n    #  print(paste(\"precision_expon_lambda \", solution_exp_lambda$estim.precis) )\n    #  if(is.na(solution_exp_lambda$root)){\n    #    print(paste(\"no expon_lambda_roots found\"))\n    #  }\n      print(paste(\"expon_lambda root \", lambda_exp_root))\n      \n      \n   #   print (\"--solving for p---\")\n      solution_p <- multiroot(f = p_derivative_mod, start = c(1), jacfunc = p_derivative_jacfunc(), parms = pars)\n    #  print(\"----solution_p----\")\n    #  print (solution_p)\n      print(paste(\"precision_p \", solution_p$estim.precis) )\n      if(is.na(solution_p$root)){\n          print(paste(\"no p_roots found\"))\n          c(p_root = NA, p_precision = NA,\n           # lambda_root = NA, lambda_precision = NA,\n           # lambda_exp_root = solution_exp_lambda$root, lambda_exp_precision = solution_exp_lambda$estim.precis)\n              lambda_root = NA, lambda_exp_root = lambda_exp_root)\n      }\n      else if(is.na(solution_p$estim.precis)){\n          print(paste(\"estimated precision for p is Na, won't try to estimate lambda\"))\n          c(p_root = solution_p$root, p_precision = NA,\n           # lambda_root = NA, lambda_precision = NA,\n           # lambda_exp_root = solution_exp_lambda$root, lambda_exp_precision = solution_exp_lambda$estim.precis)\n             lambda_root = NA, lambda_exp_root = lambda_exp_root)\n      }\n      else {\n          pars <- list(p = solution_p$root, node_data = node_data, mutation_position = mutation_position)\n        #  print (\"--solving for lambda---\")\n         # solution_lambda <- multiroot(f = lambda_derivative_mod, start = c(1), parms = pars)\n           lambda_root <- lambda_derivative_mod(pars)\n          #print(paste(\"precision_lambda \", solution_lambda$estim.precis) )\n         # print (\"---roots----\")\n         # print (c(p_root = solution_p$root, lambda_root = solution_lambda$root))\n            print (c(p_root = solution_p$root, lambda_root = lambda_root))\n         # if (!is.na(solution_lambda$root)){\n            c(p_root = solution_p$root, p_precision = solution_p$estim.precis,\n            lambda_root = lambda_root,\n            lambda_exp_root = lambda_exp_root)\n         # }    \n      }\n      \n  }\n  else {\n    print (\"No mutations in the subtree\")\n    c(p_root = NA, p_precision = NA,\n      lambda_root = NA, lambda_exp_root = NA)\n  }\n}\n\n\n## uniroot, outputs many roots\nfind_roots <- function(node_data, mutation_position){\n  \n  if (sum(node_data$event) != 0){\n      print (node_data)\n      print (paste(\"site \", node_data[2,1], \" node \", node_data[2,2]))\n      print (\"--number of mutations---\")\n      print (sum(node_data$event))\n      #pars <- node_data\n      pars <- list(node_data = node_data, mutation_position = mutation_position)\n      print (\"--solving for p---\")\n      #solution_p <- multiroot(f = p_derivative, start = c(1), parms = pars)\n      interval = c(0.00001, 5)\n      solution_p <- uniroot.all(f = p_derivative_mod, interval, parms = pars)\n      print(\"----solution_p----\")\n      print (solution_p)\n      if(length(solution_p) == 0){\n        print(paste(\"no p_roots found for interval \", interval[1], \"-\", interval[2]))\n      }\n      else {\n        pars <- list(p = solution_p[1], node_data = node_data, mutation_position = mutation_position)\n        print (\"--solving for lambda---\")\n        solution_lambda <- multiroot(f = lambda_derivative_mod, start = c(1), parms = pars, verbose=TRUE)\n        print (\"---roots----\")\n        print (c(p_root = solution_p[1], lambda_root = solution_lambda$root))\n        c(p_root = solution_p[1], lambda_root = solution_lambda$root)\n      }\n  }\n}\n\n## ln of true likelihood (mutation happens somewhere at the branch, no presumptions about where exactly)\n## of the node_data given exponential model with parameter lambda\nlnlikelihood_exp <-function(node_data, lambda, fishy = FALSE){\n  beta_branches = node_data[node_data[\"event_indicator\"]==0,]\n  alpha_branches = node_data[node_data[\"event_indicator\"]==1,]\n  if (fishy){\n    apply_res1 <- apply( alpha_branches, 1,\n                         function(elm){ \n                           if(!is.na(elm[\"event_indicator\"])){ #if (nrow(dataframe) == 0), <apply> still tries to apply the function to.. header? the list is not empty: it contains the header\n                             talpha1 <- as.numeric(elm[\"t_branch_end\"])\n                             talpha0 <- as.numeric(elm[\"t_branch_start\"])\n                             log(lambda)+log(talpha1-talpha0)\n                           }  \n                           else { 0 }\n                         })\n  }\n  else {\n    apply_res1 <- apply( alpha_branches, 1,\n                       function(elm){ \n                         if(!is.na(elm[\"event_indicator\"])){ #if (nrow(dataframe) == 0), <apply> still tries to apply the function to.. header? the list is not empty: it contains the header\n                           talpha1 <- as.numeric(elm[\"t_branch_end\"])\n                           talpha0 <- as.numeric(elm[\"t_branch_start\"])\n                           survival <- exp(lambda*(talpha0-talpha1))\n                           log(1-survival)\n                         }  \n                         else { 0 }\n                       })\n  }\n  apply_res2 <-  apply( beta_branches, 1,\n                        function(elm){ \n                          if(!is.na(elm[\"event_indicator\"])){ #if (nrow(dataframe) == 0), <apply> still tries to apply the function to.. header? the list is not empty: it contains the header\n                            tbeta1 <- as.numeric(elm[\"t_branch_end\"])\n                            tbeta0 <- as.numeric(elm[\"t_branch_start\"])\n                            tbeta0 -  tbeta1\n                          }  \n                          else { 0 }\n                        })\n  \n  lnL <-sum(apply_res1) + lambda*sum(apply_res2)\n  c(lnL = lnL, AIC = aic(lnL, 1))\n}\n\n## ln of true likelihood (mutation happens somewhere at the branch, no presumptions about where exactly)\n## of the node_data given weibull model with parameters lambda and p\nlnlikelihood_weibull <-function(node_data, lambda, p, fishy = FALSE){\n  beta_branches = node_data[node_data[\"event_indicator\"]==0,]\n  alpha_branches = node_data[node_data[\"event_indicator\"]==1,]\n  if (fishy){\n    apply_res1 <- apply( alpha_branches, 1,\n                         function(elm){ \n                           if(!is.na(elm[\"event_indicator\"])){ #if (nrow(dataframe) == 0), <apply> still tries to apply the function to.. header? the list is not empty: it contains the header\n                             talpha1 <- as.numeric(elm[\"t_branch_end\"])\n                             talpha0 <- as.numeric(elm[\"t_branch_start\"])\n                             talpha_middle <- (talpha1+talpha0)/2\n                             log(p) + p*log(lambda)+(p-1)*log(talpha_middle)+log(talpha1-talpha0)\n                           }  \n                           else { 0 }\n                         })\n    \n  }\n  else {\n  apply_res1 <- apply( alpha_branches, 1,\n                       function(elm){ \n                         if(!is.na(elm[\"event_indicator\"])){ #if (nrow(dataframe) == 0), <apply> still tries to apply the function to.. header? the list is not empty: it contains the header\n                           talpha1 <- as.numeric(elm[\"t_branch_end\"])\n                           talpha0 <- as.numeric(elm[\"t_branch_start\"])\n                           survival <- exp((lambda^p)*(talpha1^p)*( ((talpha0/talpha1)^p) - 1 ))\n                           log(1-survival)\n                         }  \n                         else { 0 }\n                       })\n  }\n  apply_res2 <-  apply( beta_branches, 1,\n                        function(elm){ \n                          if(!is.na(elm[\"event_indicator\"])){ #if (nrow(dataframe) == 0), <apply> still tries to apply the function to.. header? the list is not empty: it contains the header\n                            tbeta1 <- as.numeric(elm[\"t_branch_end\"])\n                            tbeta0 <- as.numeric(elm[\"t_branch_start\"])\n                            (tbeta1^p)*( ((tbeta0/tbeta1)^p) - 1 )  \n                          }  \n                          else { 0 }\n                        })\n  \n  lnL <-sum(apply_res1) + (lambda^p)*sum(apply_res2)\n  c(lnL = lnL, AIC = aic(lnL, 2))\n}\n\n# lnl - loglikelihood, p - number of parameters in the model\naic <- function (lnL, p){\n  2*(p-lnL)\n}\n\n# LR  LR = 2*(lnL1-lnL2) approximately follows a chi-square distribution with 1 degree of freedom\nlrt <- function (node_data, lambda_exp, lambda_weib, p, fishy = FALSE){\n  weibull <- lnlikelihood_weibull(node_data, lambda = lambda_weib, p = p, fishy)\n  exponential <- lnlikelihood_exp(node_data, lambda = lambda_exp, fishy)\n  LR <- 2*(weibull[1]-exponential[1])\n  print (\"weibull\")\n  print (weibull)\n  print (\"exponential\")\n  print (exponential)\n  print (\"LR\")\n  print (LR)\n  LR\n}\n\n\n\n## estimate parameters and compute lr\n## files like \"h1_single_root_31_03_truelambda_fishy\" were printed here\nlrt_procedure <-function(prot, tag, fishy = FALSE){\n  prot_data <-  read.csv(paste(c(\"C:/Users/weidewind/workspace/perlCoevolution/TreeUtils/Phylo/MutMap/likelihood/nsyn/\",prot,\"_for_LRT.csv\"), collapse=\"\"),stringsAsFactors=FALSE)  \n  splitted <- split(prot_data, list(prot_data$site, prot_data$ancestor_node), drop=TRUE)\n  sink(file = paste(c(\"C:/Users/weidewind/workspace/perlCoevolution/TreeUtils/Phylo/MutMap/likelihood/nsyn/\",prot,\"_single_root_\", tag), collapse=\"\"), append = FALSE, type = c(\"output\", \"message\"),\n       split = FALSE)\n # roots <- lapply (splitted, find_single_root, mutation_position = \"end\")\n   significant <- lapply (names(splitted), function(elm, mutation_position){\n     mutation_position <- mutation_position\n     node_data <- splitted[[elm]]\n     node_roots <- find_single_root(node_data, mutation_position)\n     if(!is.na(node_roots) && all(!is.na(node_roots)) && node_roots[\"p_precision\"] < 1e-5  ){\n        lr <-lrt (node_data, lambda_exp = node_roots[\"lambda_exp_root\"], lambda_weib = node_roots[\"lambda_root\"], p = node_roots[\"p_root\"], fishy)\n        if(!is.na(lr) && lr > 3.8){\n          c(node = elm,  lambda_exp = node_roots[\"lambda_exp_root\"], lambda_weib = node_roots[\"lambda_root\"], p = node_roots[\"p_root\"], lr = lr)\n        }\n     } \n     }, mutation_position = \"end\")\n \n lapply (significant, function(elm){\n   if (!is.null(elm)){\n     print (elm)\n   }\n })\n  sink()\n\n}\n\n## computes parameters for all nodes, outputs only complete sets of parameters\nparameters <-function(prot, tag, fishy = FALSE){\n  prot_data <-  read.csv(paste(c(\"C:/Users/weidewind/workspace/perlCoevolution/TreeUtils/Phylo/MutMap/likelihood/nsyn/\",prot,\"_for_LRT.csv\"), collapse=\"\"),stringsAsFactors=FALSE)  \n  splitted <- split(prot_data, list(prot_data$site, prot_data$ancestor_node), drop=TRUE)\n  # roots <- lapply (splitted, find_single_root, mutation_position = \"end\")\n  parameters <- lapply (names(splitted), function(elm, mutation_position){\n    mutation_position <- mutation_position\n    node_data <- splitted[[elm]]\n    node_roots <- find_single_root(node_data, mutation_position)\n    if(!is.na(node_roots) &&  all(is.finite(node_roots)) && node_roots[\"p_precision\"] < 1e-5  ){\n     # lr <-lrt (node_data, lambda_exp = node_roots[\"lambda_exp_root\"], lambda_weib = node_roots[\"lambda_root\"], p = node_roots[\"p_root\"], fishy)\n        c(node = elm, lambda_exp = node_roots[\"lambda_exp_root\"], lambda_weib = node_roots[\"lambda_root\"], p = node_roots[\"p_root\"])\n    } \n  }, mutation_position = \"end\")\n  \n  parameters  <- Filter(Negate(is.null), parameters)\n}\n\n\n## computes all parameters, plots p and log(p) histograms\nparameter_hists <- function(prot, fishy = FALSE){\n  params <- parameters(prot, fishy)\n  p_hists(params)\n}\n\n## plots p and log(p) histograms given a params list (computed by parameters function)\np_hists <- function(params){\n  p_roots <- sapply(params, function(elm) {\n    as.numeric(elm[[\"p.p_root\"]])\n  })\n  h <- hist(p_roots, breaks = 30, plot = FALSE)\n  plot(h,  main = paste(\"Histogram of \",prot, \" p\"), xlab = \"p\")\n  lh <- hist(log(p_roots), breaks = 30, plot = FALSE)\n  plot(lh,  main = paste(\"Histogram of \",prot, \" log(p)\"), xlab = \"log(p)\")\n}\n\n\n## selects lamdas corresponding to  p>threshold if right == TRUE \n## ( p <= threshold if right == FALSE)\n## and plots a histogram \nlambda_hist <- function(prot, params, threshold, right = TRUE){\n  p_roots <- sapply(h3_params, function(elm) {\n    as.numeric(elm[[\"p.p_root\"]])\n  })\n  boolean <- sapply(h3_params, function(elm) {\n    \n    if (as.numeric(elm[[\"p.p_root\"]]) > threshold) {right == TRUE}\n    else {right == FALSE}\n  })\n  \n  lambda <- sapply(h3_params[boolean], function(elm) {\n    as.numeric(elm[\"lambda_weib.lambda_root\"])\n  })\n  if (right){\n    sign = \">\"\n  }\n  else {\n    sign = \"<=\"\n  }\n  h <- hist(lambda, breaks = 30, plot = FALSE)\n  plot(h,  main = paste(\"Histogram of \",prot, \" lambda for p\", sign, \" \", threshold), xlab = \"lambda\")\n}\n\n## Procedures\n\n### compute parameters, make LRT, print to file\n### files like \"h1_single_root_31_03_truelambda_fishy\" come from this function\nlrt_procedure(\"h1\", \"31_03_truelambda\", FALSE)\nlrt_procedure(\"h3\", \"31_03_truelambda\", FALSE)\nlrt_procedure(\"n1\", \"31_03_truelambda\", FALSE)\nlrt_procedure(\"n2\", \"31_03_truelambda\", FALSE)\n\nlrt_procedure(\"h1\", \"31_03_truelambda_fishy\", TRUE)\nlrt_procedure(\"h3\", \"31_03_truelambda_fishy\", TRUE)\nlrt_procedure(\"n1\", \"31_03_truelambda_fishy\", TRUE)\nlrt_procedure(\"n2\", \"31_03_truelambda_fishy\", TRUE)\n###\n\n\n### (1) compute all parameters (time-consuming) and plot p hists\n \nparameter_hists(\"n1\", TRUE)\nparameter_hists(\"n2\", TRUE)\nparameter_hists(\"h1\", TRUE)\nparameter_hists(\"h3\", TRUE)\n\n###\n\n### (2) More convenient than (1), keeps prot_params which can be reused (say, for plotting lambda hists )\n\n# compute all parameters (time-consuming)\nh1_params <- parameters(\"h1\", TRUE)\nh3_params <- parameters(\"h3\", TRUE)\nn1_params <- parameters(\"n1\", TRUE)\nn2_params <- parameters(\"n2\", TRUE)\n\n# plot p hists\np_hists(h1_params)\n###\n\n### plot lambda hists for different p\nlambda_hist(\"h3\", h3_params, threshold = 1, right = FALSE)\nlambda_hist(\"h1\", h1_params, threshold = 1, right = FALSE)\n###\n\n\n###\nboolean <- sapply(h3_params, function(elm) {\n  \n  if (as.numeric(elm[[\"p.p_root\"]]) < 0) {right == TRUE}\n  else {right == FALSE}\n})\n\n\n\n## find p and lambda for all ancestor_nodes\nprot <- \"h1\" \nprot_data <-  read.csv(paste(c(\"C:/Users/weidewind/workspace/perlCoevolution/TreeUtils/Phylo/MutMap/likelihood/nsyn/\",prot,\"_for_LRT.csv\"), collapse=\"\"),stringsAsFactors=FALSE)  \n#mock example:\n#prot_data <-  read.csv(\"C:/Users/weidewind/workspace/perlCoevolution/TreeUtils/Phylo/MutMap/likelihood/mock_example_for_LRT.csv\")\nsplitted <- split(prot_data, list(prot_data$site, prot_data$ancestor_node), drop=TRUE)\nsink(file = paste(c(\"C:/Users/weidewind/workspace/perlCoevolution/TreeUtils/Phylo/MutMap/likelihood/nsyn/\",prot,\"_single_root_modified_alpha_plus_exp_lambda\"), collapse=\"\"), append = FALSE, type = c(\"output\", \"message\"),\n     split = FALSE)\nroots <- lapply (splitted, find_single_root, mutation_position = \"end\")\nsink()\nsink (file = paste(c(\"C:/Users/weidewind/workspace/perlCoevolution/TreeUtils/Phylo/MutMap/likelihood/nsyn/\",prot,\"_all_roots\"), collapse=\"\"), append = FALSE, type = c(\"output\", \"message\"),\n      split = FALSE)\nprint(roots)\nsink()\n\n## LRT\n######\nsink (file = paste(c(\"C:/Users/weidewind/workspace/perlCoevolution/TreeUtils/Phylo/MutMap/likelihood/nsyn/\",prot,\"_LRTs\"), collapse=\"\"), append = FALSE, type = c(\"output\", \"message\"),\n      split = FALSE)\nlrts <- lapply(names(roots), function(elm) {\n  print (elm)\n  node_roots <- roots[[elm]]\n  node_data <- splitted[[elm]]\n  if(!is.na(node_roots) && all(!is.na(node_roots))  && node_roots[\"lambda_exp_precision\"] < 1e-5 && node_roots[\"lambda_precision\"] < 1e-5 && node_roots[\"p_precision\"] < 1e-5  ){\n    lrt (node_data, lambda_exp = node_roots[\"lambda_exp_root\"], lambda_weib = node_roots[\"lambda_root\"], p = node_roots[\"p_root\"])\n  }  \n})\nsink()\n\n\n###\n\n## plot function\nprot <- \"h3\" \nprot_data <-  read.csv(paste(c(\"C:/Users/weidewind/workspace/perlCoevolution/TreeUtils/Phylo/MutMap/likelihood/nsyn/\",prot,\"_for_LRT.csv\"), collapse=\"\"),stringsAsFactors=FALSE)  \nsplitted <- split(prot_data, list(prot_data$site, prot_data$ancestor_node), drop=TRUE)\n\n\ndraw_p_derivative <- function(splitted, anc_node){\n  node_data <- splitted[[anc_node]]\n  parms <- list(node_data = node_data, mutation_position = \"end\")\n  y <- sapply(seq(from = -5, to = 5, by = 0.05), function (elm){function_p_derivative(elm,parms)})\n  plot( x = seq(from = -5, to = 5, by = 0.05), y, type = 'l', xlab = \"p\", ylab = \"f2\", axes=F, xaxt=\"n\", yaxt=\"n\", main = anc_node, ylim = c(-10, 5))\n  axis(1, pos=0)\n  axis(2, pos=0)\n  abline(v=0, h=0)\n}\n#node_data <- splitted$\"238.INTNODE1364\" - yep\n#node_data <- splitted$\"99.INTNODE1465\"\n#node_data <- splitted$\"238.INTNODE2422\" - downward trend\n#111.INTNODE2428 - upward trend\n#169.INTNODE2434 - upward trend\n#289.INTNODE2399 - downward trend\n#207.INTNODE2425\n#562.INTNODE2231 - estim precis for p is 1\n\nsink(file = paste(c(\"C:/Users/weidewind/workspace/perlCoevolution/TreeUtils/Phylo/MutMap/likelihood/nsyn/function_tests\"), collapse=\"\"), append = FALSE, type = c(\"output\", \"message\"),\n     split = FALSE)\ndraw_p_derivative(splitted,\"175.INTNODE4215\" )\nsink()\n\n\n##\nlnlikelihood_exp(splitted[[\"162.INTNODE2226\"]], lambda = 0.003555556)\nroots[[\"562.INTNODE2231\"]]\n## misc tests\n#parms <- list(node_data = splitted[[\"418.INTNODE2406\"]], mutation_position = \"end\")\n#function_p_derivative(-1, parms)\n#node_data <- splitted$\"7.INTNODE1628\"\n#print (sum(node_data$event))\n#find_roots(node_data)\n\n#tapply(prot_data$event, list(prot_data$site, prot_data$ancestor_node),sum)\n\n## do not use this version; I keep it here as an example of model with two functions (and two unknowns)\n## Error in stode(y, time, func, parms = parms, ...) :\n## Model function must return a list of values, of which first element has length =length of y\n# ??-?? ????, ??? t_branch_start ????? ???? ????? ????, ? ???????? ????, ? ??????, ?? ?????????.\n# ???? ?????? ????, ???????? ????????\nmodel <- function (x, parms) {\n  with (as.list(c(parms)),{\n    D <- sum (node_data$event)\n    f1 <- (- D) + ( x[1]^x[2] )*\n      sum( apply( node_data[node_data$event==0,], 1,\n                  function(elm){\n                    tbeta1 <- as.numeric(elm[\"t_branch_end\"])\n                    tbeta0 <- as.numeric(elm[\"t_branch_start\"])\n                    tbeta1^x[2]-tbeta0^x[2]\n                  })) \n    f2 <- D*sum( apply( node_data[node_data$event==0,], 1,\n                  function(elm){\n                    tbeta1 <- as.numeric(elm[\"t_branch_end\"])\n                    tbeta0 <- as.numeric(elm[\"t_branch_start\"])\n                    if (tbeta0 == 0){logtbeta0 = 0} # mutation can't die before it's birth\n                    else {logtbeta0 = log(tbeta0)}\n                    #   print(log(tbeta0))\n                    #   print(log(tbeta1))\n                    #   print (\"---\")\n                    log(tbeta1)*tbeta1^x-logtbeta0*tbeta0^x\n                  }))/\n          sum (apply( node_data[node_data$event==0,], 1,\n                  function(elm){\n                    tbeta1 <- as.numeric(elm[\"t_branch_end\"])\n                    tbeta0 <- as.numeric(elm[\"t_branch_start\"])\n                    tbeta1^x[2]-tbeta0^x[2]\n                  })) - \n          sum (apply( node_data[node_data$event==1,], 1,\n                  function(elm){\n                    if (!is.na(elm[\"t_branch_start\"])){\n                      talpha0 <- as.numeric(elm[\"t_branch_start\"])\n                      if (talpha0 == 0){logtalpha0 = 0}\n                      else {logtalpha0 = log(talpha0)}\n                      logtalpha0\n                    }\n                    else {\n                      0\n                    }\n                  })) -\n          D/x[2]\n  \n    c(F1 = f1, F2 = f2)\n \n  })\n  \n}\n\nparms <- c(node_data = node_data)\n(ss <- multiroot(f = model, start = c(1, 1), parms = parms))\n\n##\n\n\n\n# second argumnet 1 means that we are working with rows\n#lengths <- apply(node_data[node_data$event==0,], 1, function(elm) {as.numeric(elm[\"t_branch_end\"])-as.numeric(elm[\"t_branch_start\"])})\n\n# sum from neva weibull list 2, eq (1). Checked.\n#sum1 <- sum(apply(node_data[node_data$event==0,],1, function(elm) {(as.numeric(elm[\"t_branch_end\"]))^2-(as.numeric(elm[\"t_branch_start\"]))^2}))\n\n",
    "created" : 1459937402902.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1078066268",
    "id" : "2E2CB813",
    "lastKnownWriteTime" : 1459936361,
    "path" : "~/R/weibull_estimation.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}