{
    "contents" : "install.packages(\"rootSolve\")\nlibrary(\"rootSolve\")\ninstall.packages(\"rbenchmark\")\nlibrary(\"rbenchmark\")\n\n\n## multiroot, finds only one root \nfind_single_root <- function(data, mutation_position, rkvector, jack = FALSE, verbose=TRUE){\n  # data is a list of dataframes, node_data is a dataframe\n\n  if (length(data) == 1){\n    mode <- \"single\"\n    node_data <- data[[1]]\n    rkvector <- c(1)\n    names(rkvector) <- names(data)\n    if (verbose){\n      print (\"Running in single mode\")\n    }\n  }\n  else {\n    mode <- \"group\"\n    if (verbose){\n      print (\"Running in group mode\")\n    }\n    if(is.null(rkvector)){\n      stop (\"In group mode argument rkvector must be provided\")\n    }\n  }\n  \n  \n  if (mode == \"group\" || (mode == \"single\" && sum(node_data$event) != 0)){\n    if (verbose && mode == \"single\"){\n      print (node_data)\n      print (paste(\"site \", node_data[2,1], \" node \", node_data[2,2]))\n      print (paste(\"number of mutations \", sum(node_data$event)))\n    }\n    \n    pars <- list(data = data, rkvector, mutation_position = mutation_position)\n    lambda_exp_root <- lambda_derivative_exp(pars)\n    if (verbose){print(paste(\"expon_lambda root \", lambda_exp_root))}\n    \n    # if p root is negative, search for positive root\n    p = -1\n    init = 1\n    count = 1\n    \n    while(!is.na(p) && p < 0 && count < 6){\n      if (jack){\n        solution_p <- multiroot(f = p_derivative, start = c(init), jacfunc = p_derivative_jacfunc, jactype = \"fullusr\", parms = pars)\n      }\n      else {\n        solution_p <- multiroot(f = p_derivative, start = c(init), parms = pars)\n      }\n      p <-solution_p$root\n      init <- init + 3\n      count <- count + 1\n    }\n    \n    if (verbose){print(paste(\"precision_p \", solution_p$estim.precis) )}\n    if(is.na(solution_p$root)){\n      print(paste(\"no p_roots found\"))\n      c(p_root = NA, p_precision = NA,\n        lambda_root = NA, lambda_exp_root = lambda_exp_root)\n    }\n    else if(is.na(solution_p$estim.precis)){\n      if (verbose){\n        print(paste(\"p_root is \",solution_p$root, \" but estimated precision for p is Na, won't try to estimate lambda\"))\n      }\n      c(p_root = solution_p$root, p_precision = NA,\n        lambda_root = NA, lambda_exp_root = lambda_exp_root)\n    }\n    \n    else {\n      pars <- list(p = solution_p$root, data = data, rkvector, mutation_position = mutation_position)\n      lambda_root <- lambda_derivative_weib(pars)\n      if (verbose){ print (c(p_root = solution_p$root, lambda_root = lambda_root))}\n      c(p_root = solution_p$root, p_precision = solution_p$estim.precis,\n        lambda_root = lambda_root,\n        lambda_exp_root = lambda_exp_root)\n    }\n    \n  }\n  else {\n    if (verbose && mode == \"single\"){ \n      print (paste(\"site \", node_data[2,1], \" node \", node_data[2,2]))\n      print (\"No mutations in the subtree, all roots NA\")\n    }\n    c(p_root = NA, p_precision = NA,\n      lambda_root = NA, lambda_exp_root = NA)\n  }\n}\n\n## computes parameters for all nodes, outputs only complete sets of parameters\n#parameters <-function(prot, tag, fishy = FALSE){\nparameters <-function(data, mutation_position = \"end\", fishy = FALSE, filter = TRUE, jack = FALSE, verbose = FALSE){\n  \n  ps <- lapply (names(data), function(elm, mut_pos){\n    mutation_position <- mut_pos\n    node_data <- data[elm]\n    node_roots <- find_single_root(node_data, mutation_position, jack = jack, verbose = verbose)\n    if (!filter || filter && !is.na(node_roots) &&  all(is.finite(node_roots)) && node_roots[\"p_precision\"] < 1e-5 ) {\n        c(node = elm, lambda_exp = node_roots[\"lambda_exp_root\"], lambda_weib = node_roots[\"lambda_root\"], p = node_roots[\"p_root\"], p_precision = node_roots[\"p_precision\"])\n    }\n\n  }, mut_pos = mutation_position)\n  \n  if (filter) {\n    ps  <- Filter(Negate(is.null), ps)\n  }\n  ps\n}\n\nprot <- \"h1\"\nprot_data <-  read.csv(paste(c(\"C:/Users/weidewind/workspace/perlCoevolution/TreeUtils/Phylo/MutMap/likelihood/nsyn/\",prot,\"_for_LRT.csv\"), collapse=\"\"),stringsAsFactors=FALSE)  \nsplitted <- split(prot_data, list(prot_data$site, prot_data$ancestor_node), drop=TRUE)\n\n\nh1_prms2 <-parameters(splitted, fishy = TRUE, filter= FALSE)\nh1_prms_jack <-parameters(splitted, fishy = TRUE, jack = TRUE, filter= FALSE)\nh1_prms_no_negative_roots <-parameters(splitted, fishy = TRUE, filter= FALSE)\n\nsink(\"C:/Users/weidewind/workspace/perlCoevolution/TreeUtils/Phylo/MutMap/likelihood/nsyn/wtf_with_precision_h1\")\nh1_wtf_precision <-parameters(splitted, fishy = TRUE, filter= FALSE, verbose = TRUE)\nsink()\n\nsnbenchmark(parameters(splitted, fishy = TRUE, jack = TRUE, filter= FALSE), parameters(splitted, fishy = TRUE, filter= FALSE),  replications = 1)\n\n\n# how much does it take to compute all jackobians?\ntest_jack <- function(x, splitted){\n  ps <- lapply (names(splitted), function(elm){\n    node_data <- splitted[[elm]]\n    parms <- list(node_data = node_data, mutation_position = \"end\")\n    node_jacks <- p_derivative_jacfunc(x, parms)\n  })\n}\n\nbenchmark(parameters(splitted, fishy = TRUE, jack = TRUE, filter= FALSE), parameters(splitted, fishy = TRUE, filter= FALSE),  replications = 1)\n\nbenchmark(test_jack(1, splitted), test_jack(2, splitted), replications = 3)\n\n\n\n\nlrts <-lrt_procedure(splitted, \"testtag\", fishy = TRUE, threshold = 3.84, parameters = h1_prms2)\n\n##\ntry_df <- data.frame(matrix(unlist(h1_prms), nrow=length(h1_prms), byrow=T),stringsAsFactors=FALSE)\nnames(try_df) <- c(\"node\", \"lambda_exp_root\", \"lambda_root\", \"p_root\", \"p_precision\" )\n## equivalent to\nh1nodes <- sapply(h1_prms, function(elm){\n    elm[\"node\"]\n})\nh1lambdaexp <- sapply(h1_prms, function(elm){\n  as.numeric(elm[\"lambda_exp.lambda_exp_root\"])\n})\nh1lambdawei <- sapply(h1_prms, function(elm){\n  as.numeric(elm[\"lambda_weib.lambda_root\"])\n})\nh1p <- sapply(h1_prms, function(elm){\n  as.numeric(elm[\"p.p_root\"])\n})\nh1pprec <-sapply(h1_prms, function(elm){\n  as.numeric(elm[\"p_precision.p_precision\"])\n})\n\ndframe <- data.frame(node = h1nodes, lambda_exp_root = h1lambdaexp,lambda_root = h1lambdawei, p_root =  h1p, p_precision = h1pprec)\n##\nhead(dframe, 50)\n\n\n\n## Inconvenient. computes all parameters, plots p and log(p) histograms\nparameter_hists <- function(data, mutation_position = \"end\", fishy = FALSE){\n  params <- parameters(data, mutation_position = \"end\", fishy)\n  p_hists(params)\n}\n\n\n\n## plots p and log(p) histograms given a params list (computed by parameters function)\n\np_hists <- function(params){\n  params <- params[sapply(params, function(elm){!is.na(elm[[\"p.p_root\"]])})] #select nodes with p root defined\n  p_roots <- sapply(params, function(elm) {\n    as.numeric(elm[[\"p.p_root\"]])\n  })\n  h <- hist(p_roots, breaks = 30, plot = FALSE)\n  plot(h,  main = paste(\"Histogram of \",prot, \" p\"), xlab = \"p\")\n  lh <- hist(log(p_roots), breaks = 30, plot = FALSE)\n  plot(lh,  main = paste(\"Histogram of \",prot, \" log(p)\"), xlab = \"log(p)\")\n}\n\n\n## selects lamdas corresponding to  p>threshold if right == TRUE \n## ( p <= threshold if right == FALSE)\n## and plots a histogram \nlambda_hist <- function(prot, params, threshold, right = TRUE){\n  params <- params[sapply(params, function(elm){!is.na(elm[[\"p.p_root\"]])})] #select nodes with p root defined\n  p_roots <- sapply(params, function(elm) {\n    as.numeric(elm[[\"p.p_root\"]])\n  })\n  boolean <- sapply(params, function(elm) {\n    \n    if (as.numeric(elm[[\"p.p_root\"]]) > threshold) {right == TRUE}\n    else {right == FALSE}\n  })\n  \n  lambda <- sapply(params[boolean], function(elm) {\n    as.numeric(elm[\"lambda_weib.lambda_root\"])\n  })\n  if (right){\n    sign = \">\"\n  }\n  else {\n    sign = \"<=\"\n  }\n  h <- hist(lambda, breaks = 30, plot = FALSE)\n  plot(h,  main = paste(\"Histogram of \",prot, \" lambda for p\", sign, \" \", threshold), xlab = \"lambda\")\n  h <- hist(log(lambda), breaks = 30, plot = FALSE)\n  plot(h,  main = paste(\"Histogram of \",prot, \" log(lambda) for p\", sign, \" \", threshold), xlab = \"lambda\")\n}\n",
    "created" : 1459939066689.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2198740818",
    "id" : "58082BA6",
    "lastKnownWriteTime" : 1460620332,
    "path" : "C:/Users/weidewind/workspace/evolikelihood/R/MLE_parameters.R",
    "project_path" : "R/MLE_parameters.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}