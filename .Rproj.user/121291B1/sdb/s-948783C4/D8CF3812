{
    "contents" : "#!/usr/bin/env Rscript\nlist.of.packages <- c(\"parallel\", \"ArgumentCheck\", \"optparse\")\nnew.packages <- setdiff(list.of.packages, installed.packages()[,\"Package\"])\nif(length(new.packages)) install.packages(new.packages, repos='http://cran.us.r-project.org')\ninstall.packages(file.path(getwd(), fsep = .Platform$file.sep), repos = NULL, type=\"source\")\nlibrary(evolike)\nlibrary(parallel)\nlibrary(optparse)\n\n\noption_list = list(\n  make_option(c(\"-p\", \"--prot\"), type=\"character\", default=NULL, \n              help=\"protein: h1, h3, n1 or n2\", metavar=\"character\"),\n  make_option(c(\"-m\", \"--model\"), type=\"character\", default=\"weibull\", \n              help=\"model distr: weibull or exponential\", metavar=\"character\")\n); \n\nopt_parser = OptionParser(option_list=option_list);\nopt = parse_args(opt_parser);\n\nwith (opt, {\n  \n  Check <- ArgumentCheck::newArgCheck()\n  \n  if (!(prot %in% c(\"h1\", \"h3\", \"n1\", \"n2\"))){ \n    ArgumentCheck::addError(\n      msg = \"valid 'prot' options: h1, h3, n1, n2\",\n      argcheck = Check\n    )\n  }\n\n  if (!(model %in% c(\"weibull\", \"exponential\"))){\n    ArgumentCheck::addError(\n      msg = \"valid 'model' options: weibull, exponential\",\n      argcheck = Check\n    )\n  }\n \n  #* Return errors and warnings (if any)\n  ArgumentCheck::finishArgCheck(Check)\n\n\n## load mygroups \ndata(\"mygroups\")\n\nprot_groups <-mygroups[grep(paste(c(\"^\", prot, \"_\"), collapse = \"\"), names(mygroups))]\ncategories <- 1\n\nprot_data <-  read.csv(file.path(getwd(), \"data\", paste(c(prot,\"_for_LRT.csv\"), collapse=\"\"),fsep = .Platform$file.sep),stringsAsFactors=FALSE)  \nsplitted <- split(prot_data, list(prot_data$site, prot_data$ancestor_node), drop=TRUE)\n\ncount_cores <- 18\n# Initiate cluster\ncl <- makeCluster(count_cores)\nclusterExport(cl, list(\"prot\", \"prot_groups\", \"splitted\", \"model\"), envir = environment())\nclusterCall(cl, function() library(evolike))\n\nprot_groups_names <- names(prot_groups)\nem_results_list <- parLapply(cl, prot_groups_names, function(group_name){\n  sink (file.path(getwd(), \"output\",\"group_likelihood\", model, prot, paste(c(\"logs_\", group_name), collapse= \"\"), fsep = .Platform$file.sep))\n  \n  print (group_name)\n  group <- prot_groups[group_name][[1]]\n  group_pattern <- sapply(group, function (e){\n    paste(c(\"^\", e, \"\\\\.\"), collapse = \"\")\n  })\n  grepper <- paste(group_pattern,collapse=\"|\")\n  group_nodes <- grep(grepper, names(splitted))\n  group_splitted <- splitted[group_nodes]\n  \n  compl <- !(seq(1,length(splitted),1) %in% group_nodes)\n  compl_splitted <- splitted[compl]\n  \n  params <-parameters(group_splitted, mutation_position = \"middle\",  filter = TRUE, jack = FALSE, pack = \"rootsolve\", verbose = FALSE)\n  compl_params <-parameters(compl_splitted, mutation_position = \"middle\",  filter = TRUE, jack = FALSE, pack = \"rootsolve\", verbose = FALSE)\n  \n  sink() \n  \n  sink (file.path(getwd(), \"output\",\"group_likelihood\", model, prot, group_name, fsep = .Platform$file.sep))\n  em_results <- em_procedure(data=group_splitted, params=params, model = model,  cluster.number= 1, init_method = \"cluster\", mutation_position = \"middle\",  filtering = \"single\", trace = FALSE)\n  sink() \n  sink (file.path(getwd(), \"output\",\"group_likelihood\", model, prot, paste(c(group_name, \"_complement\"), collapse= \"\"), fsep = .Platform$file.sep))\n  em_results <- em_procedure(data=compl_splitted, params=compl_params, model = model,  cluster.number= 1, init_method = \"cluster\", mutation_position = \"middle\",  filtering = \"single\", trace = FALSE)\n  sink() \n  \n  \n  em_results\n})\n\nstopCluster(cl)\n})",
    "created" : 1467043007426.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1310591385",
    "id" : "D8CF3812",
    "lastKnownWriteTime" : 1463587302,
    "path" : "C:/Users/weidewind/workspace/evolike/demo/groups.R",
    "project_path" : "demo/groups.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}