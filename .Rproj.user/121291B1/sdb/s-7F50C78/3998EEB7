{
    "contents" : "\n# makes em procedure for groups\nwood_groups_test <- function(prot, model, tag){\n  data(\"mygroups\")\n  \n  \n  #prot <- \"h3\"\n  prot_groups <-mygroups[grep(paste(c(\"^\", prot, \"_\"), collapse = \"\"), names(mygroups))]\n  #model <- \"weibull\"\n  categories <- 1\n  \n  prot_data <-  read.csv(file.path(getwd(), \"data\", paste(c(prot,\"_for_LRT.csv\"), collapse=\"\"),fsep = .Platform$file.sep),stringsAsFactors=FALSE)  \n  splitted <- split(prot_data, list(prot_data$site, prot_data$ancestor_node), drop=TRUE)\n  \n  count_cores <- detectCores() - 1\n  # Initiate cluster\n  cl <- makeCluster(count_cores)\n  clusterExport(cl, list(\"prot\", \"prot_groups\", \"splitted\", \"model\"), envir = environment())\n  clusterCall(cl, function() library(evolike))\n  \n  prot_groups_names <- names(prot_groups)\n  em_results_list <- parLapply(cl, prot_groups_names, function(group_name){\n    sink (file.path(getwd(), \"output\",\"group_likelihood\", model, prot, paste(c(\"logs_\", group_name), collapse= \"\"), tag, fsep = .Platform$file.sep))\n    \n    print (group_name)\n    group <- prot_groups[group_name][[1]]\n    group_pattern <- sapply(group, function (e){\n      paste(c(\"^\", e, \"\\\\.\"), collapse = \"\")\n    })\n    grepper <- paste(group_pattern,collapse=\"|\")\n    group_nodes <- grep(grepper, names(splitted))\n    group_splitted <- splitted[group_nodes]\n    \n    compl <- !(seq(1,length(splitted),1) %in% group_nodes)\n    compl_splitted <- splitted[compl]\n    \n    params <-parameters(group_splitted, mutation_position = \"middle\",  filter = TRUE, jack = FALSE, pack = \"rootsolve\", verbose = FALSE)\n    compl_params <-parameters(compl_splitted, mutation_position = \"middle\",  filter = TRUE, jack = FALSE, pack = \"rootsolve\", verbose = FALSE)\n    \n    sink() \n    \n    sink (file.path(getwd(), \"output\",\"group_likelihood\", model, prot, group_name, fsep = .Platform$file.sep))\n    em_results <- em_procedure(data=group_splitted, params=params, model = model,  cluster.number= 1, init_method = \"cluster\", mutation_position = \"middle\",  filtering = \"single\", trace = FALSE)\n    sink() \n    sink (file.path(getwd(), \"output\",\"group_likelihood\", model, prot, paste(c(group_name, \"_complement\"), collapse= \"\"), fsep = .Platform$file.sep))\n    em_results <- em_procedure(data=compl_splitted, params=compl_params, model = model,  cluster.number= 1, init_method = \"cluster\", mutation_position = \"middle\",  filtering = \"single\", trace = FALSE)\n    sink() \n    \n    \n    em_results\n  })\n  \n  \n  \n  \n  stopCluster(cl)\n}\n\n\n\n\n## takes a posterior probabilities from wood_likelihood analysis (you must explicitly select the optimal number of categories)\nchisq_groups_test < -function(prot, categories, tag){\n  data(\"mygroups\")\n  model <- \"weibull\"\n  prot_groups <-mygroups[grep(paste(c(\"^\", prot, \"_\"), collapse = \"\"), names(mygroups))]\n  \n  em_output <- parse_em_output(prot, model, categories)\n  best <- best_output(em_output)\n  path <- file.path(getwd(), \"output\", \"wood_likelihood\", model, prot, names(best), fsep = .Platform$file.sep)\n  em_file <-  readLines(path)\n  zeroline <- tail(grep('^\\\\s+\\\\[,1\\\\]', em_file,  value = FALSE, perl = TRUE), 1)\n  lowpart <- em_file[seq(zeroline+1,length(em_file),1)]\n  lastline <- head(grep('^\\\\[1\\\\]', lowpart,  value = FALSE, perl = TRUE), 1)\n  rpart <- lowpart[seq(1, lastline-1, 1)]\n  \n  \n  count_cores <- detectCores() - 1\n  # Initiate cluster\n  cl <- makeCluster(count_cores)\n  clusterExport(cl, list(\"prot\", \"rpart\", \"prot_groups\", \"splitted\", \"model\", \"categories\", \"best\"), envir = environment())\n  clusterCall(cl, function() library(evolike))\n  \n  prot_groups_names <- names(prot_groups)\n  em_results_list <- parLapply(cl, prot_groups_names, function(group_name){\n    sink (file.path(getwd(), \"output\", \"chisq\", model, prot, group_name, tag, fsep = .Platform$file.sep))\n    \n    group <- prot_groups[group_name][[1]]\n    rvectors <- lapply(rpart, function(row){\n      splittedrow <- unlist(strsplit(row, '\\\\s+'))\n      my_params <- lapply( tail(splittedrow, length(splittedrow)), function(elm){\n        elm\n      }) \n      \n    })\n    \n    df <- data.frame(matrix(unlist(rvectors), nrow=length(rvectors), byrow=T),stringsAsFactors=FALSE)\n    rownames(df) <- df[,1]\n    df <- df[,seq(2, ncol(df), 1)]\n    \n    group_pattern <- sapply(group, function (e){\n      paste(c(\"^\", e, \"\\\\.\"), collapse = \"\")\n    })\n    grepper <- paste(group_pattern,collapse=\"|\")\n    group_nodes <- grep(grepper, rownames(df))\n    group_df <- df[group_nodes,]\n    \n    compl_nodes <- !(seq(1,nrow(df),1) %in% group_nodes)\n    compl_df <- df[compl_nodes,]\n    \n    ageing <- sapply(seq(1, categories, 1), function(cat){\n      if (best[[1]]$params[cat,\"p\"] > 1){TRUE} else {FALSE}\n    })\n    \n    \n    ageing_g <- sum(sapply(group_df[,(ageing)], function(e){sum(as.numeric(e))}))\n    adapt_g <- sum(sapply(group_df[,!(ageing)], function(e){sum(as.numeric(e))}))\n    ageing_c <- sum(sapply(compl_df[,(ageing)], function(e){sum(as.numeric(e))}))\n    adapt_c <- sum(sapply(compl_df[,!(ageing)], function(e){sum(as.numeric(e))}))\n    \n    tbl <- matrix(c(ageing_g, adapt_g, ageing_c, adapt_c), ncol = 2, byrow = TRUE, nrow = 2)\n    colnames(tbl) <- c(\"ageing\", \"adapt\")\n    rownames(tbl) <- c(\"group\", \"compl\")\n    print(tbl)\n    \n    print(chisq.test(tbl))\n    print(fisher.test(tbl))\n    sink() \n    \n    \n  })\n  \n  stopCluster(cl)\n\n}\n\n\nbest_output_file <- function (em_output){\n  bics <- sapply(em_output, function (elm){\n    elm$bic\n  })\n  sorted_bics <-sort(bics)\n  good_names <- names(head(sorted_bics, 1))\n  em_output<- em_output[good_names]\n}\n\n\n",
    "created" : 1464356366804.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "800937051",
    "id" : "3998EEB7",
    "lastKnownWriteTime" : 1464620600,
    "path" : "C:/Users/weidewind/workspace/evolike/R/GroupTest.R",
    "project_path" : "R/GroupTest.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}