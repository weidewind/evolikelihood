{
    "contents" : "## fishy = FALSE: ln of true likelihood (mutation happens somewhere at the branch, no presumptions about where exactly)\n## of the node_data given exponential model with parameter lambda\n## fishy = TRUE: ln of likelihood computed according to eq (1) on page 1,\n## Adot taken at the middle of the branch, (talpha1-talpha0) = length of the branch\nlnlikelihood_exp <-function(node_data, lambda, fishy = FALSE){\n  if (class(node_data) == \"list\"){\n    node_data <- node_data[[1]]\n  }\n  beta_branches = node_data[node_data[\"event_indicator\"]==0,]\n  alpha_branches = node_data[node_data[\"event_indicator\"]==1,]\n  if (fishy){\n    apply_res1 <- apply( alpha_branches, 1,\n                         function(elm){ \n                           if(!is.na(elm[\"event_indicator\"])){ #if (nrow(dataframe) == 0), <apply> still tries to apply the function to.. header? the list is not empty: it contains the header\n                             talpha1 <- as.numeric(elm[\"t_branch_end\"])\n                             talpha0 <- as.numeric(elm[\"t_branch_start\"])\n                             talpha_middle <- (talpha1+talpha0)/2\n                             log(lambda)+log(talpha1-talpha_middle) #changed\n                           }  \n                           else { 0 }\n                         })\n  }\n  else {\n    apply_res1 <- apply( alpha_branches, 1,\n                         function(elm){ \n                           if(!is.na(elm[\"event_indicator\"])){ #if (nrow(dataframe) == 0), <apply> still tries to apply the function to.. header? the list is not empty: it contains the header\n                             talpha1 <- as.numeric(elm[\"t_branch_end\"])\n                             talpha0 <- as.numeric(elm[\"t_branch_start\"])\n                             survival <- exp(lambda*(talpha0-talpha1))\n                             log(1-survival)\n                           }  \n                           else { 0 }\n                         })\n  }\n  apply_res2 <-  apply( beta_branches, 1,\n                        function(elm){ \n                          if(!is.na(elm[\"event_indicator\"])){ #if (nrow(dataframe) == 0), <apply> still tries to apply the function to.. header? the list is not empty: it contains the header\n                            tbeta1 <- as.numeric(elm[\"t_branch_end\"])\n                            tbeta0 <- as.numeric(elm[\"t_branch_start\"])\n                            tbeta0 -  tbeta1\n                          }  \n                          else { 0 }\n     \n                          })\n  #added\n  if(fishy){\n      apply_res3 <-  apply( alpha_branches, 1,\n                        function(elm){ \n                          if(!is.na(elm[\"event_indicator\"])){ #if (nrow(dataframe) == 0), <apply> still tries to apply the function to.. header? the list is not empty: it contains the header\n                            talpha1 <- as.numeric(elm[\"t_branch_end\"])\n                            talpha0 <- as.numeric(elm[\"t_branch_start\"])\n                            talpha_middle <- (talpha1+talpha0)/2\n                            talpha0 -  talpha_middle\n                          }  \n                          else { 0 }\n                        })\n  }\n  \n  if (fishy){\n      lnL <-sum(apply_res1) + lambda*(sum(apply_res2)+sum(apply_res3))\n  }\n  else{\n      lnL <-sum(apply_res1) + lambda*sum(apply_res2)\n  }\n  c(lnL = lnL, AIC = aic(lnL, 1))\n}\n\n## fishy = FALSE: ln of true likelihood (mutation happens somewhere at the branch, no presumptions about where exactly)\n## of the node_data given weibull model with parameters lambda and p\n## fishy = TRUE: ln of likelihood computed according to eq (1) on page 1,\n## Adot taken at the middle of the branch, (talpha1-talpha0) = length of the branch\nlnlikelihood_weibull <-function(node_data, lambda, p, fishy = FALSE){\n  if (class(node_data) == \"list\"){\n    node_data <- node_data[[1]]\n  }\n  beta_branches = node_data[node_data[\"event_indicator\"]==0,]\n  alpha_branches = node_data[node_data[\"event_indicator\"]==1,]\n  if (fishy){\n    apply_res1 <- apply( alpha_branches, 1,\n                         function(elm){ \n                           if(!is.na(elm[\"event_indicator\"])){ #if (nrow(dataframe) == 0), <apply> still tries to apply the function to.. header? the list is not empty: it contains the header\n                             talpha1 <- as.numeric(elm[\"t_branch_end\"])\n                             talpha0 <- as.numeric(elm[\"t_branch_start\"])\n                             talpha_middle <- (talpha1+talpha0)/2\n\n                             #log(p) + p*log(lambda)+(p-1)*log( talpha_middle)+log(talpha1-talpha0)\n                             log(p) + p*log(lambda)+(p-1)*log( talpha_middle)+log(talpha1-talpha_middle)\n                             #print (\"p to die\")\n                             #print (log(p) + p*log(lambda)+(p-1)*log( talpha_middle)+log(talpha1-talpha_middle))\n                           }  \n                           else { 0 }\n                         })\n    \n  }\n  else {\n    apply_res1 <- apply( alpha_branches, 1,\n                         function(elm){ \n                           if(!is.na(elm[\"event_indicator\"])){ #if (nrow(dataframe) == 0), <apply> still tries to apply the function to.. header? the list is not empty: it contains the header\n                             talpha1 <- as.numeric(elm[\"t_branch_end\"])\n                             talpha0 <- as.numeric(elm[\"t_branch_start\"])\n                             survival <- exp((lambda^p)*(talpha1^p)*( ((talpha0/talpha1)^p) - 1 ))\n                             log(1-survival)\n                           }  \n                           else { 0 }\n                         })\n  }\n  apply_res2 <-  apply( beta_branches, 1,\n                        function(elm){ \n                          if(!is.na(elm[\"event_indicator\"])){ #if (nrow(dataframe) == 0), <apply> still tries to apply the function to.. header? the list is not empty: it contains the header\n                            tbeta1 <- as.numeric(elm[\"t_branch_end\"])\n                            tbeta0 <- as.numeric(elm[\"t_branch_start\"])\n                            if (tbeta1 == 0){0}\n                            else {\n                              (tbeta1^p)*( ((tbeta0/tbeta1)^p) - 1 )  \n                            }\n                            #print (\"p to survive on beta\")\n                            #print ((tbeta1^p)*( ((tbeta0/tbeta1)^p) - 1 ) )\n                          }  \n                          else { 0 }\n                        })\n  ## added\n  if (fishy){\n      apply_res3 <-  apply( alpha_branches, 1,\n                        function(elm){ \n                          if(!is.na(elm[\"event_indicator\"])){ #if (nrow(dataframe) == 0), <apply> still tries to apply the function to.. header? the list is not empty: it contains the header\n                            talpha1 <- as.numeric(elm[\"t_branch_end\"])\n                            talpha0 <- as.numeric(elm[\"t_branch_start\"])\n                            talpha_middle <- (talpha1+talpha0)/2\n                            #print (\"p to survive on alpha\")\n                            #print ((talpha_middle^p)*( ((talpha0/talpha_middle)^p) - 1 ))\n                            (talpha_middle^p)*( ((talpha0/talpha_middle)^p) - 1 )  \n                          }  \n                          else { 0 }\n                        })\n  }\n  \n  \n  if (fishy){\n      lnL <-sum(apply_res1) + (lambda^p)*(sum(apply_res2)+sum(apply_res3))\n  }\n  else {\n      lnL <-sum(apply_res1) + (lambda^p)*sum(apply_res2)\n  }\n\n  c(lnL = lnL, AIC = aic(lnL, 2))\n}\n\n# lnl - loglikelihood, p - number of parameters in the model\naic <- function (lnL, p){\n  2*(p-lnL)\n}\n\n# lnl - loglikelihood, p - number of free parameters in the model, n - sample size\nbic < -function (lnL, model = c(\"weibull\", \"exponential\"), cluster.number, n){\n  if (model == \"weibull\"){\n    p = 3*cluster.number -1;\n  }\n  else {\n    p = 2*cluster.number -1;\n  }\n  -2*lnL + p*log(n)\n}\n\n# LR  LR = 2*(lnL1-lnL2) approximately follows a chi-square distribution with 1 degree of freedom\nlrt <- function (node_data, lambda_exp, lambda_weib, p, fishy = FALSE, verbose = FALSE){\n  weibull <- lnlikelihood_weibull(node_data, lambda = lambda_weib, p = p, fishy)\n  exponential <- lnlikelihood_exp(node_data, lambda = lambda_exp, fishy)\n  LR <- 2*(weibull[1]-exponential[1])\n  if(verbose){\n    print (\"weibull\")\n    print (weibull)\n    print (\"exponential\")\n    print (exponential)\n    print (\"LR\")\n    print (LR)\n  }\n  LR\n}\n\n\n\n\n## Compute LR\n## takes an already computed set of parameters (with parameters(..., filter=FALSE))\n## OR, if parameters = NULL, computes them \n## ! mutation_position and parameters cannot be defined simultaneously\n## threshold - significance threshold (default - 3.84, value of chi-square distr with 1 degree of freedom for sign level 0.05)\n## Prints parameters and lr for significant nodes\n## outputs parameters and lr for all nodes\n## files like \"h1_single_root_31_03_truelambda_fishy\" were printed here\n\nlrt_procedure <-function(data, prot, tag, fishy = FALSE, threshold = 3.84,  mutation_position = \"end\", pack = \"rootsolve\", params = NULL){\n # if (!is.null(params)){\n #   warning(\"Parameters are defined, therefore mutation_position will be ignored\")\n  #}\n  sink(file = paste(c(getwd(), \"/output/\" ,prot,\"_single_root_\", tag), collapse=\"\"), append = FALSE, type = c(\"output\", \"message\"),\n       split = FALSE)\n  \n  lratios <- lapply (names(data), function(elm, mutation_position){\n    mutation_position <- mutation_position\n    node_data <- data[elm]\n    if (is.null(params)){\n      node_roots <- as.list(find_single_root(node_data, mutation_position, pack=pack))\n    }\n    else {\n      node_roots <- params[params$node == elm,]\n    }\n    if(!is.na(node_roots) && all(!is.na(node_roots)) && node_roots$p_precision < 1e-5  ){\n      \n      lr <-lrt (node_data, lambda_exp = node_roots$lambda_exp_root, lambda_weib = node_roots$lambda_weib_root, p = node_roots$p_root, fishy= TRUE, verbose=FALSE)\n      row <- c(node = elm,  lambda_exp = node_roots$lambda_exp_root, lambda_weib = node_roots$lambda_weib_root, p = node_roots$p_root, p_precision = node_roots$p_precision, lr = lr)\n      if(!is.na(lr) && lr > threshold){\n        print (c(node = elm,  lambda_exp = node_roots$lambda_exp_root, lambda_weib = node_roots$lambda_weib_root, p = node_roots$p_root, p_precision = node_roots$p_precision, lr = lr))\n      }\n    } \n    else {\n      row <- c(node = elm,  lambda_exp = node_roots$lambda_exp_root, lambda_weib = node_roots$lambda_weib_root, p = node_roots$p_root, p_precision = node_roots$p_precision, lr = NA) \n    }\n  }, mutation_position)\n  sink()\n  \n  lratios\n}\n\n\n## verbose mode also prints a file with parameters for all nodes\n\nlrt_all <- function(mutation_position = \"middle\", fishy = TRUE,  pack = \"rootsolve\", tag = \"defaulttag\", verbose = TRUE){\n  prots <- c(\"h1\", \"h3\", \"n1\", \"n2\")\n  for (pr in prots){\n    prot <- pr\n    prot_data <-  read.csv(paste(c(getwd(), \"/input/\" ,prot,\"_for_LRT.csv\"), collapse=\"\"),stringsAsFactors=FALSE)  \n    splitted <- split(prot_data, list(prot_data$site, prot_data$ancestor_node), drop=TRUE)\n    if (verbose){\n      sink(file = paste(c(getwd(), \"/output/\" ,prot,\"_all_parms_\", tag), collapse=\"\"))\n    }\n    prms <-parameters(splitted,  mutation_position = mutation_position,  verbose = verbose, pack = pack, filter= FALSE)\n    if (verbose){sink()}\n    lrt_procedure(data = splitted, prot = prot, tag = tag, fishy=fishy, params = prms)\n    sink()\n  }\n}\n\n###\n## tests and procedures\n\n\n#lrt_all(mutation_position = \"middle\", fishy = TRUE, tag = \"middle_search\", pack = \"rootsolve\", verbose = TRUE)\n\n\n#benchmark(parameters(splitted,  jack = FALSE, pack = \"nleqslv\", filter= FALSE), parameters(splitted,  jack = FALSE, pack = \"rootsolve\", filter= FALSE),  replications = 1)\n\n##check that there are no zero-length branches with mutations\nno_muts_on_zero_branches <-function(prot){\n  prot_data <-  read.csv(paste(c(getwd(), \"/input/\" ,prot,\"_for_LRT.csv\"), collapse=\"\"),stringsAsFactors=FALSE)  \n  nullength <- prot_data[prot_data[\"event_indicator\"] == 1,]\n  nullength <-nullength[nullength[\"t_branch_end\"]-nullength[\"t_branch_start\"] == 0,]\n  if (nrow(nullength) == 0){TRUE}\n  else {FALSE}\n}\n\n# how much does it take to compute all jackobians?\ntest_jack <- function(x, splitted){\n  ps <- lapply (names(splitted), function(elm){\n    node_data <- splitted[[elm]]\n    parms <- list(node_data = node_data, mutation_position = \"end\")\n    node_jacks <- p_derivative_jacfunc(x, parms)\n  })\n}\n\n#prot <- \"h1\"\n#prot_data <-  read.csv(paste(c(getwd(), \"/input/\" ,prot,\"_for_LRT.csv\"), collapse=\"\"),stringsAsFactors=FALSE)  \n#splitted <- split(prot_data, list(prot_data$site, prot_data$ancestor_node), drop=TRUE)\n#node_data <- splitted[\"151.INTNODE4195\"]\n#node_roots <- find_single_root(node_data, mutation_position = \"middle\", jack = FALSE, pack = \"nleqslv\", verbose = TRUE)\n\n#draw_hazard <-function(data=splitted, nodename = \"78.NTNODE4232\", to = 20, by = 0.01, mutation_position = \"middle\", fishy = TRUE)\n#draw_lnlikelihood (data=splitted, nodename = \"169.INTNODE2065\", to = 20, by = 0.01, mutation_position = \"middle\", fishy = TRUE)\n#draw_hazard(data=splitted, nodename = \"78.INTNODE4232\", to = 20, by = 0.05, mutation_position = \"middle\", fishy = TRUE)\n#h1_params <-parameters(splitted, mutation_position = \"middle\", filter= FALSE)\n#h1_prms_jack <-parameters(splitted, fishy = TRUE, jack = TRUE, filter= FALSE)\n#h1_prms_no_negative_roots <-parameters(splitted, fishy = TRUE, filter= FALSE)\n\n#sink(\"C:/Users/weidewind/workspace/perlCoevolution/TreeUtils/Phylo/MutMap/likelihood/nsyn/likelihood_games_h1\")\n#h1_likelihood_games <-parameters(splitted, mutation_position = \"middle\", filter= FALSE, verbose = TRUE)\n#sink()\n#lrt_procedure(data = splitted, prot = prot, tag = \"likelihood_games\", fishy=TRUE, params = h1_likelihood_games)\n#sink()\n",
    "created" : 1459940503253.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "190266437",
    "id" : "A521A49E",
    "lastKnownWriteTime" : 1461763456,
    "path" : "C:/Users/weidewind/workspace/evolikelihood/R/LRT.R",
    "project_path" : "R/LRT.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}