{
    "contents" : "list.of.packages <- c(\"rgl\")\nnew.packages <- setdiff(list.of.packages, installed.packages()[,\"Package\"])\nif(length(new.packages)) install.packages(new.packages)\n\n## EM algorithm\n\n\n## prepare data\n\n\n## clusterize observed MLE parameters\n## construct rk vectors (1/0) for EM (based on cluster membership)\n## find initial a (and b) parameters for EM (maximisation)\n## compute initial weights based on (1/0) rk vectors (expectation)\n## returns list with two values: vector of weights and matrix of parameters\n\n\n\ninitialize_by_clustering <- function (data, params, mutation_position = \"middle\", cluster.number = 4){\n#  f <- filter_unsolved(data=data, params=params)\n#  fparams = f$fparams\n # fdata = f$fdata\n  parclust <-params[,c(\"lambda_weib_root\", \"p_root\")]\n  \n  #filtered <-params[!is.na(params$p_precision) ,]\n # filtered <-filtered[filtered$p_precision< 1e-5  ,]\n  #df <-filtered[,c(\"lambda_weib_root\", \"p_root\")]\n # data_filtered <- data[filtered$node]\n  \n  scaling <-max(parclust[,2])/max(parclust[,1])\n  parclust_scaled <- data.frame(lambda_weib_root = scaling*parclust[,1], p_root = parclust[,2])\n  \n  clusters <-kmeans(parclust_scaled, cluster.number)\n  categories <- seq(from = 1, to = cluster.number, by = 1)\n  rkvectors <- sapply(categories, function(k){\n    rk <-sapply(clusters$cluster, function(category){\n      if (category == k){1} \n      else {0}\n    })\n  })\n  rownames(rkvectors) <- params$node\n  \n  init_params <-compute_params(data = data, rkvectors = rkvectors, mutation_position = mutation_position)\n  \n  init_weights <- compute_weights(rkvectors)\n  \n  list(iparameters = init_params, iweights = init_weights)\n}\n\n\n## alternative: choose random a (and b) \n## set equal weights for all categories\n## returns list with two values: vector of weights and matrix of parameters\n\ninitialize_random <- function (){\n  \n}\n\ninitialize_by <- function (init_params, init_weights, cluster.number = 4){\n  if (class(init_params) != \"numeric\") {\n    stop (\"Invalid argument params: expected vector of length 2*cluster.number\")\n  }\n  if (length(init_params) != 2*cluster.number) {\n    stop (\"Invalid params length: expected vector of length 2*cluster.number\")\n  }\n  if (length(init_weights) != cluster.number) {\n    stop (\"Invalid weights length: expected vector of length cluster.number\")\n  }\n  \n  categories <- seq(from = 1, to = cluster.number, by = 1)\n  init_params <-matrix(init_params, ncol =2, nrow = 4, byrow = TRUE)\n  colnames(init_params) = c(\"lambda\", \"p\")\n\n  \n  list(iparameters = init_params, iweights = init_weights)\n}\n\nfilter_unsolved <-function(data, params){\n  fparams <-params[!is.na(params$p_precision) ,]\n  fparams <-fparams[fparams$p_precision< 1e-5  ,]\n  fdata <- data[fparams$node]\n  list(fdata = fdata, fparams = fparams)\n}\n\nfilter_unsolved_and_single <-function(data, params){\n  fparams <-params[!is.na(params$p_precision),]\n  fparams <-fparams[fparams$p_precision< 1e-5,]\n  fparams <-fparams[fparams$events > 1,]\n  fdata <- data[fparams$node]\n  list(fdata = fdata, fparams = fparams)\n}\n\n\nem_procedure <-function(data, params, iter = 100, cluster.number= 4, init_method = c(\"cluster\", \"random\", \"by\"), init_params = NULL, init_weights = NULL, mutation_position = \"middle\",  filtering = c(\"single\", \"unsolved\"), trace = TRUE){\n  if (filtering == \"single\"){\n    fi <- filter_unsolved_and_single(data=data, params=params)\n    fdata <- fi$fdata\n    fparams <- fi$fparams\n  }\n  else if (filtering == \"unsolved\"){\n    fi <- filter_unsolved(data=data, params=params)\n    fdata <- fi$fdata\n    fparams <- fi$fparams\n  }\n  else {\n    stop(\"Invalid argument filtering: must be either single or unsolved\")\n  }\n  \n  if (init_method == \"cluster\") {\n    init <- initialize_by_clustering(data=fdata, params=fparams, mutation_position = mutation_position, cluster.number = cluster.number)\n    iparameters <- init$iparameters\n    iweights <- init$iweights \n  }\n  else if (init_method == \"random\"){\n    init <- initialize_random(data=fdata, params=fparams, mutation_position = mutation_position, cluster.number = cluster.number)\n    iparameters <- init$iparameters\n    iweights <- init$iweights \n  }\n  else if (init_method == \"by\"){\n    if (is.null(init_params) || is.null(init_weights)){\n      stop (\"Chosen inititalization method requires init_params and init_weights arguments\")\n    }\n    init <- initialize_by(init_params, init_weights, cluster.number = cluster.number)\n    iparameters <- init$iparameters\n    iweights <- init$iweights \n  }\n  else {\n    stop (paste (\"Invalid initialization method \", method ))\n  }\n  \n  em_results <- em(fdata, iparameters, iweights, iter= iter, mutation_position = mutation_position, cluster.number = cluster.number, trace = trace)\n\n}\n\n\nem <- function(data, parameters, weights, iter = 100, cluster.number= 4, mutation_position = \"middle\", trace = TRUE){\n  #todo: data must be filtered (before initialization?), and this new set must be used in em/ params (for every node) are not to be confused with cluster paramteres.\n  #  init <- initialize (data, params=parameters, mutation_position = mutation_position, cluster.number = cluster.number, method = \"cluster\")\n  #  parameters <- init$iparameters\n  #  weights <- init$iiweights\n  \n  #  dev.new()\n  #  h1=dev.cur()\n  #  myplot1 <- scatterplot3d(parameters[1,\"lambda\"], parameters[1,\"p\"], weights[1], color= \"red\", type=\"h\", pch=19, xlim = c(max(parameters[1,\"lambda\"] - 0.1,0),parameters[1,\"lambda\"] + 0.1), ylim= c(max(parameters[1,\"p\"] - 1,0),parameters[1,\"p\"] + 1), zlim = c(0,1))\n  #  dev.new()\n  #  h2=dev.cur()\n  #  myplot2 <- scatterplot3d(parameters[2,\"lambda\"], parameters[2,\"p\"], weights[2], color= \"blue\", type=\"h\", pch=19, xlim = c(max(parameters[2,\"lambda\"] - 0.1,0),parameters[2,\"lambda\"] + 0.1), ylim= c(max(parameters[2,\"p\"] - 1,0),parameters[2,\"p\"] + 1), zlim = c(0,1))\n  #  dev.new()\n  #  h3=dev.cur()\n  # myplot3 <- scatterplot3d(parameters[3,\"lambda\"], parameters[3,\"p\"], weights[3], color= \"green\", type=\"h\", pch=19, xlim = c(max(parameters[3,\"lambda\"] - 0.1,0),parameters[3,\"lambda\"] + 0.1), ylim= c(max(parameters[3,\"p\"] - 1,0),parameters[3,\"p\"] + 1), zlim = c(0,1))\n  # dev.new()\n  #  h4=dev.cur()\n  # myplot4 <- scatterplot3d(parameters[3,\"lambda\"], parameters[4,\"p\"], weights[4], color= \"black\", type=\"h\", pch=19, xlim = c(max(parameters[4,\"lambda\"] - 0.1,0),parameters[4,\"lambda\"] + 0.1), ylim= c(max(parameters[4,\"p\"] - 1,0),parameters[4,\"p\"] + 1), zlim = c(0,1))\n  # dev.new()\n  # h5=dev.cur()\n  if (trace){\n   myplot <- scatterplot3d(parameters[1,\"lambda\"], parameters[1,\"p\"], weights[1], color= \"red\", type=\"h\", xlim = c(0, 0.1), ylim = c(0,10), zlim = c(0,1), pch=19)\n    # dev.set(h5)\n    myplot$points3d(parameters[2,\"lambda\"], parameters[2,\"p\"], weights[2], col= \"blue\", pch=19, type=\"h\")\n    myplot$points3d(parameters[3,\"lambda\"], parameters[3,\"p\"], weights[3], col= \"green\", pch=19, type=\"h\")\n    myplot$points3d(parameters[4,\"lambda\"], parameters[4,\"p\"], weights[4], col= \"black\",pch=19,  type=\"h\")\n  }\n  old_lnL <- NULL\n  for (i in seq(1,iter,1)){\n    print (paste(c(\"------------Step \", i), collapse=\"\"))\n    rkvectors <- compute_rkvectors(data=data, parameters=parameters, weights=weights)\n    parameters <- compute_params(data=data, rkvectors=rkvectors, mutation_position = mutation_position)\n    weights <- compute_weights(rkvectors)\n    print(rkvectors)\n    print(weights)\n    # dev.set(h1)\n    #  myplot1$points3d(parameters[1,\"lambda\"], parameters[1,\"p\"], weights[1], col= \"red\", type=\"h\")\n    # dev.set(h2)\n    # myplot2$points3d(parameters[2,\"lambda\"], parameters[2,\"p\"], weights[2], col= \"blue\", type=\"h\")\n    # dev.set(h3)\n    #  myplot3$points3d(parameters[3,\"lambda\"], parameters[3,\"p\"], weights[3], col= \"green\", type=\"h\")\n    # dev.set(h4)\n    # myplot4$points3d(parameters[4,\"lambda\"], parameters[4,\"p\"], weights[4], col= \"black\", type=\"h\")\n    \n    # dev.set(h5)\n    if (trace){\n      myplot$points3d(parameters[1,\"lambda\"], parameters[1,\"p\"], weights[1], col= \"red\", type=\"h\")\n      myplot$points3d(parameters[2,\"lambda\"], parameters[2,\"p\"], weights[2], col= \"blue\", type=\"h\")\n      myplot$points3d(parameters[3,\"lambda\"], parameters[3,\"p\"], weights[3], col= \"green\", type=\"h\")\n      myplot$points3d(parameters[4,\"lambda\"], parameters[4,\"p\"], weights[4], col= \"black\", type=\"h\")\n    }  \n    model_lnL <- compute_model_lnL(data=data, parameters=parameters, weights=weights)\n    print (\"model lnL\")\n    print(model_lnL)\n    if (!is.null(old_lnL) && model_lnL - old_lnL < 0.0001){\n      break\n    }\n    else {old_lnL <- model_lnL}\n  }\n  list(parameters=parameters, rkvectors=rkvectors, weights=weights, lnL = model_lnL)\n}\n\ncompute_weights <- function(rkvectors){\n  if (class(rkvectors) != \"matrix\"){\n    stop (paste (c(\"Invalid type of rkvectors: expected matrix, got \", class(rkvectors))))\n  }\n  categories <- seq(from = 1, to = ncol(rkvectors), by = 1)\n  weights <- sapply (categories, function (k){\n    rkvector = rkvectors[, k]\n    sum(rkvector)/length(rkvector)\n  })\n}\n\ncompute_rkvectors <- function(data, parameters, weights){\n  cluster.number = length(weights)\n  categories <- seq(from = 1, to = cluster.number, by = 1)\n  rkvectors <- sapply(categories, function(k){\n    rk <-sapply(names(data), function(nodename){\n      cat_probs <- sapply ( categories, function (cat) {\n        lnL_dat <- lnlikelihood_weibull(data[[nodename]], parameters[cat,\"lambda\"], parameters[cat,\"p\"], fishy = TRUE)\n        lnL <- lnL_dat[1]\n        weights[cat] * exp(lnL)\n      }\n      )\n      cat_probs[k]/sum(cat_probs)\n    })\n  })\n  rownames(rkvectors) <- names(data)\n  rkvectors\n}\n\ncompute_params <- function(data, rkvectors, mutation_position = \"middle\" ){\n  cluster.number = ncol(rkvectors)\n  categories <- seq(from = 1, to = cluster.number, by = 1)\n  new_params <-matrix(nrow = cluster.number, ncol = 2)\n  colnames(new_params) = c(\"lambda\", \"p\")\n  for (k in categories){\n    k_params <- find_single_root(data = data, mutation_position=mutation_position, rkvector = rkvectors[, k], jack = FALSE, pack = \"rootsolve\", verbose=TRUE)\n    new_params[k, \"p\"]  <- k_params[\"p_root\"]\n    new_params[k, \"lambda\"]  <- k_params[\"lambda_weib_root\"]\n  }\n  new_params\n}\n\n\ncompute_model_lnL <- function(data, parameters, weights){\n  cluster.number = length(weights)\n  categories <- seq(from = 1, to = cluster.number, by = 1)\n\n    likelihood_vector <-sapply(names(data), function(nodename){\n      cat_probs <- sapply ( categories, function (cat) {\n        lnL_dat <- lnlikelihood_weibull(data[[nodename]], parameters[cat,\"lambda\"], parameters[cat,\"p\"], fishy = TRUE)\n        lnL <- lnL_dat[1]\n        weights[cat] * exp(lnL)\n      }\n      )\n      sum(cat_probs)\n    })\n  \n  lnL <- sum(log(likelihood_vector))\n\n}\n\n## EM: E - compute rk vectors and weights of each category\n##     M - given rk, compute new sets of parameters for each category\n\n\n\n\n\n\n\n\n\n\n### Procedures \n#prot <- \"h1\"\n#prot_data <-  read.csv(paste(c(getwd(), \"/input/\" ,prot,\"_for_LRT.csv\"), collapse=\"\"),stringsAsFactors=FALSE)  \n#splitted <- split(prot_data, list(prot_data$site, prot_data$ancestor_node), drop=TRUE)\n#params <-parameters(splitted, mutation_position = \"middle\",  filter = TRUE, jack = FALSE, pack = \"rootsolve\", verbose = FALSE)\n\n\n#params <- data.frame(matrix(unlist(params), nrow=length(params), byrow=T),stringsAsFactors=FALSE)\n#names(params) <- c(\"node\", \"lambda_exp_root\", \"lambda_weib_root\", \"p_root\", \"p_precision\" )\n#params <- transform(params, lambda_exp_root = as.numeric(lambda_exp_root), lambda_weib_root = as.numeric(lambda_weib_root), p_root = as.numeric(p_root), p_precision = as.numeric(p_precision))\n#filtered <-params[!is.na(params$p_precision) ,]\n#filtered <-filtered[filtered$p_precision< 1e-5  ,]\n##filtered <-filtered[filtered$p_root< 30  ,]\n#df <-filtered[,c(\"lambda_weib_root\", \"p_root\")]\n#plot(df$p_root, df$lambda_weib_root, main = \"n2\")\n#plot(df$p_root, df$lambda_weib_root, xlim = c(0, 1.5), ylim = c(0, 0.1), main = \"n2\")\n#h1_kmeans <-kmeans(df, 3)\n",
    "created" : 1460551453315.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3998177778",
    "id" : "C5603543",
    "lastKnownWriteTime" : 1461678130,
    "path" : "C:/Users/weidewind/workspace/evolikelihood/R/EM.R",
    "project_path" : "R/EM.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}